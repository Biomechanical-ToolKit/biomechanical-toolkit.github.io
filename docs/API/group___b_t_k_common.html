<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>BTK: Common</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="DoxygenStyleSheet_API.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">BTK
   &#160;<span id="projectnumber">0.3dev.0</span>
   </div>
   <div id="projectbrief">Open-source library to visualize/process biomechanical data</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="classes.html"><span>Classes</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Common</div>  </div>
</div><!--header-->
<div class="contents">

<p>Common is the base of BTK. It contains required classes by others modules.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtk_1_1_acquisition.html">btk::Acquisition</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains the data related to a biomechanical acquisition.  <a href="classbtk_1_1_acquisition.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtk_1_1_analog.html">btk::Analog</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classbtk_1_1_analog.html" title="Analog channel data along the time. ">Analog</a> channel data along the time.  <a href="classbtk_1_1_analog.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtk_1_1_collection.html">btk::Collection&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of objects.  <a href="classbtk_1_1_collection.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtk_1_1_data_object.html">btk::DataObject</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Input and output entry for processes in pipelines.  <a href="classbtk_1_1_data_object.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtk_1_1_data_object_labeled.html">btk::DataObjectLabeled</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classbtk_1_1_data_object.html" title="Input and output entry for processes in pipelines. ">DataObject</a> with a label and a description.  <a href="classbtk_1_1_data_object_labeled.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtk_1_1_event.html">btk::Event</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Label a specific time/frame during an acquisition.  <a href="classbtk_1_1_event.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtk_1_1_force_platform.html">btk::ForcePlatform</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all type of force platform.  <a href="classbtk_1_1_force_platform.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtk_1_1_force_platform_type.html">btk::ForcePlatformType&lt; t, r, c &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenient class to represent a concrete force platform.  <a href="classbtk_1_1_force_platform_type.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtk_1_1_i_m_u.html">btk::IMU</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container of analog channels representing an inertial measurement unit (<a class="el" href="classbtk_1_1_i_m_u.html" title="Container of analog channels representing an inertial measurement unit (IMU). ">IMU</a>).  <a href="classbtk_1_1_i_m_u.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtk_1_1_i_m_u_type.html">btk::IMUType&lt; t &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenient class to represents a concrete <a class="el" href="classbtk_1_1_i_m_u.html" title="Container of analog channels representing an inertial measurement unit (IMU). ">IMU</a>.  <a href="classbtk_1_1_i_m_u_type.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtk_1_1_logger.html">btk::Logger</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Log mechanism to display debug message, warnings and errors.  <a href="classbtk_1_1_logger.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtk_1_1_measure.html">btk::Measure&lt; Derived &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classbtk_1_1_measure.html" title="Measure with d dimensions along the time. ">Measure</a> with <em>d</em> dimensions along the time.  <a href="classbtk_1_1_measure.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtk_1_1_meta_data.html">btk::MetaData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store data which cannot be embedded within timeseries data (calibration matrix, subject informations, ...).  <a href="classbtk_1_1_meta_data.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtk_1_1_meta_data_info.html">btk::MetaDataInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container class to store data of a <a class="el" href="classbtk_1_1_meta_data.html" title="Store data which cannot be embedded within timeseries data (calibration matrix, subject informations...">MetaData</a> object.  <a href="classbtk_1_1_meta_data_info.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtk_1_1_null_ptr.html">btk::NullPtr&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">To simplify the API when testing a shared pointer to know if it is null or not.  <a href="classbtk_1_1_null_ptr.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtk_1_1_object.html">btk::Object</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base for all objects which need to keep track of modified time.  <a href="classbtk_1_1_object.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtk_1_1_point.html">btk::Point</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Coordinates of a point in a 3D space along the time.  <a href="classbtk_1_1_point.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtk_1_1_process_object.html">btk::ProcessObject</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface to create a filter/process in a pipeline.  <a href="classbtk_1_1_process_object.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtk_1_1_wrench.html">btk::Wrench</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a wrench as position, force and moment varying during the time.  <a href="classbtk_1_1_wrench.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga465dc77180b2b2d82fd4dfa9c5c432ba"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___b_t_k_common.html#ga465dc77180b2b2d82fd4dfa9c5c432ba">btkNullPtr</a>&#160;&#160;&#160;<a class="el" href="classbtk_1_1_null_ptr.html">btk::NullPtr</a></td></tr>
<tr class="separator:ga465dc77180b2b2d82fd4dfa9c5c432ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4241aaaa133a08648262c931ee93c244"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___b_t_k_common.html#ga4241aaaa133a08648262c931ee93c244">btkSharedPtr</a>&#160;&#160;&#160;std::tr1::shared_ptr</td></tr>
<tr class="separator:ga4241aaaa133a08648262c931ee93c244"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga22be4241fdb7ff663fa9341b5486ef8a"><td class="memItemLeft" align="right" valign="top">typedef Collection&lt; Analog &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___b_t_k_common.html#ga22be4241fdb7ff663fa9341b5486ef8a">btk::AnalogCollection</a></td></tr>
<tr class="separator:ga22be4241fdb7ff663fa9341b5486ef8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf6aa3df74931783e5355a65b2a7b47e3"><td class="memItemLeft" align="right" valign="top">typedef Collection&lt; Event &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___b_t_k_common.html#gaf6aa3df74931783e5355a65b2a7b47e3">btk::EventCollection</a></td></tr>
<tr class="separator:gaf6aa3df74931783e5355a65b2a7b47e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3c2815dc5f8c1d6829e6f072a9feccf7"><td class="memItemLeft" align="right" valign="top">typedef Collection&lt; ForcePlatform &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___b_t_k_common.html#ga3c2815dc5f8c1d6829e6f072a9feccf7">btk::ForcePlatformCollection</a></td></tr>
<tr class="separator:ga3c2815dc5f8c1d6829e6f072a9feccf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2d4665b26d5965e11908156de5ea8130"><td class="memItemLeft" align="right" valign="top">typedef ForcePlatformType&lt; 1, 6, 6 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___b_t_k_common.html#ga2d4665b26d5965e11908156de5ea8130">btk::ForcePlatformType1</a></td></tr>
<tr class="separator:ga2d4665b26d5965e11908156de5ea8130"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga30d77607495e6fbefaf9540bfafd4854"><td class="memItemLeft" align="right" valign="top">typedef ForcePlatformType&lt; 2, 6, 6 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___b_t_k_common.html#ga30d77607495e6fbefaf9540bfafd4854">btk::ForcePlatformType2</a></td></tr>
<tr class="separator:ga30d77607495e6fbefaf9540bfafd4854"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadbf034603951bf4a845f780b4c6a9007"><td class="memItemLeft" align="right" valign="top">typedef ForcePlatformType&lt; 3, 8, 8 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___b_t_k_common.html#gadbf034603951bf4a845f780b4c6a9007">btk::ForcePlatformType3</a></td></tr>
<tr class="separator:gadbf034603951bf4a845f780b4c6a9007"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad41a6d99f2aa135a65cdbe028a13972d"><td class="memItemLeft" align="right" valign="top">typedef ForcePlatformType&lt; 4, 6, 6 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___b_t_k_common.html#gad41a6d99f2aa135a65cdbe028a13972d">btk::ForcePlatformType4</a></td></tr>
<tr class="separator:gad41a6d99f2aa135a65cdbe028a13972d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga488bf21c21d14bf5fb3f98e015e5333e"><td class="memItemLeft" align="right" valign="top">typedef ForcePlatformType&lt; 5, 8, 6 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___b_t_k_common.html#ga488bf21c21d14bf5fb3f98e015e5333e">btk::ForcePlatformType5</a></td></tr>
<tr class="separator:ga488bf21c21d14bf5fb3f98e015e5333e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf777c1110f4f5d66eeb63cea9d9661d"><td class="memItemLeft" align="right" valign="top">typedef ForcePlatformType&lt; 6, 12, 12 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___b_t_k_common.html#gacf777c1110f4f5d66eeb63cea9d9661d">btk::ForcePlatformType6</a></td></tr>
<tr class="separator:gacf777c1110f4f5d66eeb63cea9d9661d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga45c87d65f4db487e0ba288aa4c55ed50"><td class="memItemLeft" align="right" valign="top">typedef Collection&lt; IMU &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___b_t_k_common.html#ga45c87d65f4db487e0ba288aa4c55ed50">btk::IMUCollection</a></td></tr>
<tr class="separator:ga45c87d65f4db487e0ba288aa4c55ed50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4586222f54f1f297e1e539612eb3dbf9"><td class="memItemLeft" align="right" valign="top">typedef IMUType&lt; 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___b_t_k_common.html#ga4586222f54f1f297e1e539612eb3dbf9">btk::IMUType1</a></td></tr>
<tr class="separator:ga4586222f54f1f297e1e539612eb3dbf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4e32d74146f63924d3d02ffc3f8d8042"><td class="memItemLeft" align="right" valign="top">typedef IMUType&lt; 2 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___b_t_k_common.html#ga4e32d74146f63924d3d02ffc3f8d8042">btk::IMUType2</a></td></tr>
<tr class="separator:ga4e32d74146f63924d3d02ffc3f8d8042"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4483a6386b2a78cdea298e1744f98313"><td class="memItemLeft" align="right" valign="top">typedef Collection&lt; Point &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___b_t_k_common.html#ga4483a6386b2a78cdea298e1744f98313">btk::PointCollection</a></td></tr>
<tr class="separator:ga4483a6386b2a78cdea298e1744f98313"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab36d4ab644fe36cb0876d1e32ef745e5"><td class="memItemLeft" align="right" valign="top">typedef Collection&lt; Wrench &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___b_t_k_common.html#gab36d4ab644fe36cb0876d1e32ef745e5">btk::WrenchCollection</a></td></tr>
<tr class="separator:gab36d4ab644fe36cb0876d1e32ef745e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaa57864cc1566f5aff040de051a25e74d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaa57864cc1566f5aff040de051a25e74d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___b_t_k_common.html#gaa57864cc1566f5aff040de051a25e74d">btk::MetaDataCollapseChildrenValues</a> (std::vector&lt; T &gt; &amp;target, MetaData::ConstPointer parent, const std::string &amp;baselabel, int targetFinalSize=-1, const T &amp;blankReplacement=T())</td></tr>
<tr class="separator:gaa57864cc1566f5aff040de051a25e74d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f6559030f4231054cbaa0701e1da8e4"><td class="memItemLeft" align="right" valign="top">MetaData::Pointer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___b_t_k_common.html#ga0f6559030f4231054cbaa0701e1da8e4">btk::MetaDataCreateChild</a> (MetaData::Pointer parent, const std::string &amp;label)</td></tr>
<tr class="separator:ga0f6559030f4231054cbaa0701e1da8e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb582a90a9ac3446c4d3c435218af0c7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gabb582a90a9ac3446c4d3c435218af0c7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___b_t_k_common.html#gabb582a90a9ac3446c4d3c435218af0c7">btk::MetaDataCreateChild</a> (MetaData::Pointer parent, const std::string &amp;label, const T &amp;val)</td></tr>
<tr class="separator:gabb582a90a9ac3446c4d3c435218af0c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1c9cb493c2c8d5d0468c76aaff5ad2b5"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga1c9cb493c2c8d5d0468c76aaff5ad2b5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___b_t_k_common.html#ga1c9cb493c2c8d5d0468c76aaff5ad2b5">btk::MetaDataCreateChild</a> (MetaData::Pointer parent, const std::string &amp;label, const std::vector&lt; T &gt; &amp;val)</td></tr>
<tr class="separator:ga1c9cb493c2c8d5d0468c76aaff5ad2b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga13a674c57661a341f5e8f3a17e77fd1d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga13a674c57661a341f5e8f3a17e77fd1d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___b_t_k_common.html#ga13a674c57661a341f5e8f3a17e77fd1d">btk::MetaDataCreateChild</a> (MetaData::Pointer parent, const std::string &amp;label, const std::vector&lt; T &gt; &amp;val, int numCol)</td></tr>
<tr class="separator:ga13a674c57661a341f5e8f3a17e77fd1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaac067d992bd4c0e532c241155b56d127"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaac067d992bd4c0e532c241155b56d127"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___b_t_k_common.html#gaac067d992bd4c0e532c241155b56d127">btk::operator!=</a> (<a class="el" href="group___b_t_k_common.html#ga4241aaaa133a08648262c931ee93c244">btkSharedPtr</a>&lt; T &gt; const &amp;lhs, <a class="el" href="group___b_t_k_common.html#ga465dc77180b2b2d82fd4dfa9c5c432ba">btkNullPtr</a>&lt; T &gt; const &amp;rhs)</td></tr>
<tr class="separator:gaac067d992bd4c0e532c241155b56d127"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8d6ff26647aa21a5a4827b3a98ef79b8"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga8d6ff26647aa21a5a4827b3a98ef79b8"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___b_t_k_common.html#ga8d6ff26647aa21a5a4827b3a98ef79b8">btk::operator!=</a> (<a class="el" href="group___b_t_k_common.html#ga4241aaaa133a08648262c931ee93c244">btkSharedPtr</a>&lt; const T &gt; const &amp;lhs, <a class="el" href="group___b_t_k_common.html#ga465dc77180b2b2d82fd4dfa9c5c432ba">btkNullPtr</a>&lt; T &gt; const &amp;rhs)</td></tr>
<tr class="separator:ga8d6ff26647aa21a5a4827b3a98ef79b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae754ec63876bb7d44932b61de9ffdd2d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gae754ec63876bb7d44932b61de9ffdd2d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___b_t_k_common.html#gae754ec63876bb7d44932b61de9ffdd2d">btk::operator!=</a> (<a class="el" href="group___b_t_k_common.html#ga465dc77180b2b2d82fd4dfa9c5c432ba">btkNullPtr</a>&lt; T &gt; const &amp;lhs, <a class="el" href="group___b_t_k_common.html#ga4241aaaa133a08648262c931ee93c244">btkSharedPtr</a>&lt; T &gt; const &amp;rhs)</td></tr>
<tr class="separator:gae754ec63876bb7d44932b61de9ffdd2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7ca0455126f3ac35b05daeedd53d8f82"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga7ca0455126f3ac35b05daeedd53d8f82"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___b_t_k_common.html#ga7ca0455126f3ac35b05daeedd53d8f82">btk::operator!=</a> (<a class="el" href="group___b_t_k_common.html#ga465dc77180b2b2d82fd4dfa9c5c432ba">btkNullPtr</a>&lt; T &gt; const &amp;lhs, <a class="el" href="group___b_t_k_common.html#ga4241aaaa133a08648262c931ee93c244">btkSharedPtr</a>&lt; const T &gt; rhs)</td></tr>
<tr class="separator:ga7ca0455126f3ac35b05daeedd53d8f82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7ab39d9d0c20cddaa605da19f50e3bea"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga7ab39d9d0c20cddaa605da19f50e3bea"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___b_t_k_common.html#ga7ab39d9d0c20cddaa605da19f50e3bea">btk::operator!=</a> (<a class="el" href="group___b_t_k_common.html#ga4241aaaa133a08648262c931ee93c244">btkSharedPtr</a>&lt; T &gt; const &amp;lhs, <a class="el" href="group___b_t_k_common.html#ga465dc77180b2b2d82fd4dfa9c5c432ba">btkNullPtr</a>&lt; T &gt;(*rhs)())</td></tr>
<tr class="separator:ga7ab39d9d0c20cddaa605da19f50e3bea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc6f359814ba9a1f16fbf34190c5ce3b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gabc6f359814ba9a1f16fbf34190c5ce3b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___b_t_k_common.html#gabc6f359814ba9a1f16fbf34190c5ce3b">btk::operator!=</a> (<a class="el" href="group___b_t_k_common.html#ga4241aaaa133a08648262c931ee93c244">btkSharedPtr</a>&lt; const T &gt; const &amp;lhs, <a class="el" href="group___b_t_k_common.html#ga465dc77180b2b2d82fd4dfa9c5c432ba">btkNullPtr</a>&lt; T &gt;(*rhs)())</td></tr>
<tr class="separator:gabc6f359814ba9a1f16fbf34190c5ce3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4fb0fb6fcc2e9c21943571abc044be8f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga4fb0fb6fcc2e9c21943571abc044be8f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___b_t_k_common.html#ga4fb0fb6fcc2e9c21943571abc044be8f">btk::operator!=</a> (<a class="el" href="group___b_t_k_common.html#ga465dc77180b2b2d82fd4dfa9c5c432ba">btkNullPtr</a>&lt; T &gt;(*lhs)(), <a class="el" href="group___b_t_k_common.html#ga4241aaaa133a08648262c931ee93c244">btkSharedPtr</a>&lt; T &gt; const &amp;rhs)</td></tr>
<tr class="separator:ga4fb0fb6fcc2e9c21943571abc044be8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga236283ff8d7b3a50114ae223ad7aa2d0"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga236283ff8d7b3a50114ae223ad7aa2d0"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___b_t_k_common.html#ga236283ff8d7b3a50114ae223ad7aa2d0">btk::operator!=</a> (<a class="el" href="group___b_t_k_common.html#ga465dc77180b2b2d82fd4dfa9c5c432ba">btkNullPtr</a>&lt; T &gt;(*lhs)(), <a class="el" href="group___b_t_k_common.html#ga4241aaaa133a08648262c931ee93c244">btkSharedPtr</a>&lt; const T &gt; const &amp;rhs)</td></tr>
<tr class="separator:ga236283ff8d7b3a50114ae223ad7aa2d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6477c68c6db116817e81e712b812a441"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga6477c68c6db116817e81e712b812a441"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___b_t_k_common.html#ga6477c68c6db116817e81e712b812a441">btk::operator==</a> (<a class="el" href="group___b_t_k_common.html#ga4241aaaa133a08648262c931ee93c244">btkSharedPtr</a>&lt; T &gt; const &amp;lhs, <a class="el" href="group___b_t_k_common.html#ga465dc77180b2b2d82fd4dfa9c5c432ba">btkNullPtr</a>&lt; T &gt; const &amp;rhs)</td></tr>
<tr class="separator:ga6477c68c6db116817e81e712b812a441"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5cebe736dd71aee9002ba3910564a808"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga5cebe736dd71aee9002ba3910564a808"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___b_t_k_common.html#ga5cebe736dd71aee9002ba3910564a808">btk::operator==</a> (<a class="el" href="group___b_t_k_common.html#ga4241aaaa133a08648262c931ee93c244">btkSharedPtr</a>&lt; const T &gt; const &amp;lhs, <a class="el" href="group___b_t_k_common.html#ga465dc77180b2b2d82fd4dfa9c5c432ba">btkNullPtr</a>&lt; T &gt; const &amp;rhs)</td></tr>
<tr class="separator:ga5cebe736dd71aee9002ba3910564a808"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae150981a1edb4168ca00e9ef63592e91"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gae150981a1edb4168ca00e9ef63592e91"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___b_t_k_common.html#gae150981a1edb4168ca00e9ef63592e91">btk::operator==</a> (<a class="el" href="group___b_t_k_common.html#ga465dc77180b2b2d82fd4dfa9c5c432ba">btkNullPtr</a>&lt; T &gt; const &amp;lhs, <a class="el" href="group___b_t_k_common.html#ga4241aaaa133a08648262c931ee93c244">btkSharedPtr</a>&lt; T &gt; const &amp;rhs)</td></tr>
<tr class="separator:gae150981a1edb4168ca00e9ef63592e91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8d84f90773c5f8b7e8ebbc286145b5d2"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga8d84f90773c5f8b7e8ebbc286145b5d2"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___b_t_k_common.html#ga8d84f90773c5f8b7e8ebbc286145b5d2">btk::operator==</a> (<a class="el" href="group___b_t_k_common.html#ga465dc77180b2b2d82fd4dfa9c5c432ba">btkNullPtr</a>&lt; T &gt; const &amp;lhs, <a class="el" href="group___b_t_k_common.html#ga4241aaaa133a08648262c931ee93c244">btkSharedPtr</a>&lt; const T &gt; rhs)</td></tr>
<tr class="separator:ga8d84f90773c5f8b7e8ebbc286145b5d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa723ed699aa58738bdaee59b8a7089c7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaa723ed699aa58738bdaee59b8a7089c7"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___b_t_k_common.html#gaa723ed699aa58738bdaee59b8a7089c7">btk::operator==</a> (<a class="el" href="group___b_t_k_common.html#ga4241aaaa133a08648262c931ee93c244">btkSharedPtr</a>&lt; T &gt; const &amp;lhs, <a class="el" href="group___b_t_k_common.html#ga465dc77180b2b2d82fd4dfa9c5c432ba">btkNullPtr</a>&lt; T &gt;(*rhs)())</td></tr>
<tr class="separator:gaa723ed699aa58738bdaee59b8a7089c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga11c1078a7443d8cbbb84e7d35b9cf236"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga11c1078a7443d8cbbb84e7d35b9cf236"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___b_t_k_common.html#ga11c1078a7443d8cbbb84e7d35b9cf236">btk::operator==</a> (<a class="el" href="group___b_t_k_common.html#ga4241aaaa133a08648262c931ee93c244">btkSharedPtr</a>&lt; const T &gt; const &amp;lhs, <a class="el" href="group___b_t_k_common.html#ga465dc77180b2b2d82fd4dfa9c5c432ba">btkNullPtr</a>&lt; T &gt;(*rhs)())</td></tr>
<tr class="separator:ga11c1078a7443d8cbbb84e7d35b9cf236"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga588d95f0fb9b62f2be6a928c49bf6edc"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga588d95f0fb9b62f2be6a928c49bf6edc"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___b_t_k_common.html#ga588d95f0fb9b62f2be6a928c49bf6edc">btk::operator==</a> (<a class="el" href="group___b_t_k_common.html#ga465dc77180b2b2d82fd4dfa9c5c432ba">btkNullPtr</a>&lt; T &gt;(*lhs)(), <a class="el" href="group___b_t_k_common.html#ga4241aaaa133a08648262c931ee93c244">btkSharedPtr</a>&lt; T &gt; const &amp;rhs)</td></tr>
<tr class="separator:ga588d95f0fb9b62f2be6a928c49bf6edc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab599363aabad55119b01299c598d486b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gab599363aabad55119b01299c598d486b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___b_t_k_common.html#gab599363aabad55119b01299c598d486b">btk::operator==</a> (<a class="el" href="group___b_t_k_common.html#ga465dc77180b2b2d82fd4dfa9c5c432ba">btkNullPtr</a>&lt; T &gt;(*lhs)(), <a class="el" href="group___b_t_k_common.html#ga4241aaaa133a08648262c931ee93c244">btkSharedPtr</a>&lt; const T &gt; rhs)</td></tr>
<tr class="separator:gab599363aabad55119b01299c598d486b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Common is the base of BTK. It contains required classes by others modules. </p>
<p>This modules corresponds to the library BTKCommon </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="ga465dc77180b2b2d82fd4dfa9c5c432ba"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define btkNullPtr&#160;&#160;&#160;<a class="el" href="classbtk_1_1_null_ptr.html">btk::NullPtr</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Macro to be consistent with the API and more specificaly with btkSharedPtr. </p>

</div>
</div>
<a class="anchor" id="ga4241aaaa133a08648262c931ee93c244"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define btkSharedPtr&#160;&#160;&#160;std::tr1::shared_ptr</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Macro which uses the right shared_ptr class in BTK. To downcast a shared pointer you need to use the function static_pointer_cast. </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="ga22be4241fdb7ff663fa9341b5486ef8a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___b_t_k_common.html#ga22be4241fdb7ff663fa9341b5486ef8a">btk::AnalogCollection</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classbtk_1_1_collection.html" title="List of objects. ">Collection</a> of analog channels </p>

</div>
</div>
<a class="anchor" id="gaf6aa3df74931783e5355a65b2a7b47e3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___b_t_k_common.html#gaf6aa3df74931783e5355a65b2a7b47e3">btk::EventCollection</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classbtk_1_1_collection.html" title="List of objects. ">Collection</a> of events </p>

</div>
</div>
<a class="anchor" id="ga3c2815dc5f8c1d6829e6f072a9feccf7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___b_t_k_common.html#ga3c2815dc5f8c1d6829e6f072a9feccf7">btk::ForcePlatformCollection</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classbtk_1_1_collection.html" title="List of objects. ">Collection</a> of force platform channels </p>

</div>
</div>
<a class="anchor" id="ga2d4665b26d5965e11908156de5ea8130"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef ForcePlatformType&lt;1,6,6&gt; <a class="el" href="group___b_t_k_common.html#ga2d4665b26d5965e11908156de5ea8130">btk::ForcePlatformType1</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Represents Force platform Type-1 (6 channels: FX, FY, FZ, PX, PY, MZ) </p>

</div>
</div>
<a class="anchor" id="ga30d77607495e6fbefaf9540bfafd4854"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef ForcePlatformType&lt;2,6,6&gt; <a class="el" href="group___b_t_k_common.html#ga30d77607495e6fbefaf9540bfafd4854">btk::ForcePlatformType2</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Represents Force platform Type-2 (6 channels: FX, FY, FZ, MX, MY, MZ) </p>

</div>
</div>
<a class="anchor" id="gadbf034603951bf4a845f780b4c6a9007"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef ForcePlatformType&lt;3,8,8&gt; <a class="el" href="group___b_t_k_common.html#gadbf034603951bf4a845f780b4c6a9007">btk::ForcePlatformType3</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Represents Force platform Type-3 (8 channels: FZ1, FZ2, FZ3, FZ4, FX12, FX34, FY14, FY23) </p>

</div>
</div>
<a class="anchor" id="gad41a6d99f2aa135a65cdbe028a13972d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef ForcePlatformType&lt;4,6,6&gt; <a class="el" href="group___b_t_k_common.html#gad41a6d99f2aa135a65cdbe028a13972d">btk::ForcePlatformType4</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Represents Force platform Type-4 (Same as Type-2 + calibration matrix 6 by 6) </p>

</div>
</div>
<a class="anchor" id="ga488bf21c21d14bf5fb3f98e015e5333e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef ForcePlatformType&lt;5,8,6&gt; <a class="el" href="group___b_t_k_common.html#ga488bf21c21d14bf5fb3f98e015e5333e">btk::ForcePlatformType5</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Represents Force platform Type-5 (8 channels: FZ1, FZ2, FZ3, FZ4, FX12, FX34, FY14, FY23 + calibration matrix 6 (columns) by 8 (rows)) </p>

</div>
</div>
<a class="anchor" id="gacf777c1110f4f5d66eeb63cea9d9661d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef ForcePlatformType&lt;6,12,12&gt; <a class="el" href="group___b_t_k_common.html#gacf777c1110f4f5d66eeb63cea9d9661d">btk::ForcePlatformType6</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Represents Force platform Type-6 (12 channels: FX[1,2,3,4], FY[1,2,3,4], FZ[1,2,3,4] + calibration matrix 12 by 12) </p>

</div>
</div>
<a class="anchor" id="ga45c87d65f4db487e0ba288aa4c55ed50"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___b_t_k_common.html#ga45c87d65f4db487e0ba288aa4c55ed50">btk::IMUCollection</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classbtk_1_1_collection.html" title="List of objects. ">Collection</a> of IMUs </p>

</div>
</div>
<a class="anchor" id="ga4586222f54f1f297e1e539612eb3dbf9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef IMUType&lt;1&gt; <a class="el" href="group___b_t_k_common.html#ga4586222f54f1f297e1e539612eb3dbf9">btk::IMUType1</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Represents <a class="el" href="classbtk_1_1_i_m_u.html" title="Container of analog channels representing an inertial measurement unit (IMU). ">IMU</a> Type-1 (6D: 3 accelerometers and 3 gyroscopes) </p>

</div>
</div>
<a class="anchor" id="ga4e32d74146f63924d3d02ffc3f8d8042"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef IMUType&lt;2&gt; <a class="el" href="group___b_t_k_common.html#ga4e32d74146f63924d3d02ffc3f8d8042">btk::IMUType2</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Represents <a class="el" href="classbtk_1_1_i_m_u.html" title="Container of analog channels representing an inertial measurement unit (IMU). ">IMU</a> Type-2 (Type 1 + calibration matrix used to align accelerometers and gyroscopes on the same inertial reference frame) </p>

</div>
</div>
<a class="anchor" id="ga4483a6386b2a78cdea298e1744f98313"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___b_t_k_common.html#ga4483a6386b2a78cdea298e1744f98313">btk::PointCollection</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classbtk_1_1_collection.html" title="List of objects. ">Collection</a> of points </p>

</div>
</div>
<a class="anchor" id="gab36d4ab644fe36cb0876d1e32ef745e5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___b_t_k_common.html#gab36d4ab644fe36cb0876d1e32ef745e5">btk::WrenchCollection</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classbtk_1_1_collection.html" title="List of objects. ">Collection</a> of wrenches </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="gaa57864cc1566f5aff040de051a25e74d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void btk::MetaDataCollapseChildrenValues </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MetaData::ConstPointer&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>baselabel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>targetFinalSize</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>blankReplacement</em> = <code>T()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Collapse the <em>parent</em> children entries' values starting with the string <em>baselabel</em> and incrementing (for example: LABELS, LABELS2, LABELS3). The entries' values are stored in <em>target</em>.</p>
<p>The input <em>targetFinalSize</em> can be used to fix the number of values to collapse (by default: -1). The input <em>blankReplacement</em> can be used to fill the <em>target'</em> values which have no corresponding in the <em>parent</em> (By default: default object constructor). </p>

</div>
</div>
<a class="anchor" id="ga0f6559030f4231054cbaa0701e1da8e4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MetaData::Pointer btk::MetaDataCreateChild </td>
          <td>(</td>
          <td class="paramtype">MetaData::Pointer&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>label</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates an new <a class="el" href="classbtk_1_1_meta_data.html" title="Store data which cannot be embedded within timeseries data (calibration matrix, subject informations...">MetaData</a> or replaces its data if it already exists.</p>
<p>This method constructs a <a class="el" href="classbtk_1_1_meta_data.html" title="Store data which cannot be embedded within timeseries data (calibration matrix, subject informations...">MetaData</a> without value, with the label <em>label</em>, an empty description and is unlocked. </p>

</div>
</div>
<a class="anchor" id="gabb582a90a9ac3446c4d3c435218af0c7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void btk::MetaDataCreateChild </td>
          <td>(</td>
          <td class="paramtype">MetaData::Pointer&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>label</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a new <a class="el" href="classbtk_1_1_meta_data.html" title="Store data which cannot be embedded within timeseries data (calibration matrix, subject informations...">MetaData</a> or replaces its data if it already exists.</p>
<p>This method constructs a <a class="el" href="classbtk_1_1_meta_data.html" title="Store data which cannot be embedded within timeseries data (calibration matrix, subject informations...">MetaData</a> with a single value <em>val</em>, with the label <em>label</em>, an empty description and is unlocked. </p>

</div>
</div>
<a class="anchor" id="ga1c9cb493c2c8d5d0468c76aaff5ad2b5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void btk::MetaDataCreateChild </td>
          <td>(</td>
          <td class="paramtype">MetaData::Pointer&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>label</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a new <a class="el" href="classbtk_1_1_meta_data.html" title="Store data which cannot be embedded within timeseries data (calibration matrix, subject informations...">MetaData</a> or replaces its data if it already exists.</p>
<p>This method constructs a <a class="el" href="classbtk_1_1_meta_data.html" title="Store data which cannot be embedded within timeseries data (calibration matrix, subject informations...">MetaData</a> with a 1D vector <em>val</em> as values, with the label <em>label</em>, an empty description and is unlocked. This method gives also the possibility to create more than one entry if the vector's length is greater or equal to 256. The other entries containing the extra 256 items use the same mechanism as proposed for MetaDataCollapseChildrenValues (e.g.: LABELS, LABELS2, LABELS3). </p>

</div>
</div>
<a class="anchor" id="ga13a674c57661a341f5e8f3a17e77fd1d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void btk::MetaDataCreateChild </td>
          <td>(</td>
          <td class="paramtype">MetaData::Pointer&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>label</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numCol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a new <a class="el" href="classbtk_1_1_meta_data.html" title="Store data which cannot be embedded within timeseries data (calibration matrix, subject informations...">MetaData</a> or replaces its data if it already exists.</p>
<p>This method constructs an unlocked <a class="el" href="classbtk_1_1_meta_data.html" title="Store data which cannot be embedded within timeseries data (calibration matrix, subject informations...">MetaData</a> with a 2D vector <em>val</em> as values, an integer <em>numCol</em> for the number of column, a string <em>label</em> for the label and an empty description. This method is a recursive method which give the possibility to create more than one entry if the vector's length is greater or equal to 256 * <em>numCol</em>. The number of column must be lower than 256. The number of columns is written in the first dimension. The other entries containing the extra 256 items use the same mechanism as proposed for MetaDataCollapseChildrenValues (e.g.: LABELS, LABELS2, LABELS3). </p>

</div>
</div>
<a class="anchor" id="gaac067d992bd4c0e532c241155b56d127"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool btk::operator!= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___b_t_k_common.html#ga4241aaaa133a08648262c931ee93c244">btkSharedPtr</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___b_t_k_common.html#ga465dc77180b2b2d82fd4dfa9c5c432ba">btkNullPtr</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Inequality operator to test if a (const) shared pointer is null or not. </p>
<dl class="section note"><dt>Note</dt><dd>It is not advised to use this implementation of the operator. In pratice it will requires the instantiante a <a class="el" href="classbtk_1_1_null_ptr.html" title="To simplify the API when testing a shared pointer to know if it is null or not. ">NullPtr</a> object which will be then copied by reference.</dd></dl>
<p><b>Example</b> </p>
<div class="fragment"><div class="line">* <span class="comment">// Variable an is a btk::Analog::(Const)Pointer object.</span></div>
<div class="line">* <span class="comment">// A btk::NullPtr object is instanciated in the following condition.</span></div>
<div class="line">* <span class="keywordflow">if</span> (an != <a class="code" href="classbtk_1_1_analog.html#abe399efd10662c3a8812ab5b644dbb23">btk::Analog::Null</a>())</div>
<div class="line">* {</div>
<div class="line">*   <span class="comment">// Do whatever</span></div>
<div class="line">* }</div>
<div class="line">* </div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ga8d6ff26647aa21a5a4827b3a98ef79b8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool btk::operator!= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___b_t_k_common.html#ga4241aaaa133a08648262c931ee93c244">btkSharedPtr</a>&lt; const T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___b_t_k_common.html#ga465dc77180b2b2d82fd4dfa9c5c432ba">btkNullPtr</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Inequality operator to test if a (const) shared pointer is null or not. </p>
<dl class="section note"><dt>Note</dt><dd>It is not advised to use this implementation of the operator. In pratice it will requires the instantiante a <a class="el" href="classbtk_1_1_null_ptr.html" title="To simplify the API when testing a shared pointer to know if it is null or not. ">NullPtr</a> object which will be then copied by reference.</dd></dl>
<p><b>Example</b> </p>
<div class="fragment"><div class="line">* <span class="comment">// Variable an is a btk::Analog::(Const)Pointer object.</span></div>
<div class="line">* <span class="comment">// A btk::NullPtr object is instanciated in the following condition.</span></div>
<div class="line">* <span class="keywordflow">if</span> (an != <a class="code" href="classbtk_1_1_analog.html#abe399efd10662c3a8812ab5b644dbb23">btk::Analog::Null</a>())</div>
<div class="line">* {</div>
<div class="line">*   <span class="comment">// Do whatever</span></div>
<div class="line">* }</div>
<div class="line">* </div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="gae754ec63876bb7d44932b61de9ffdd2d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool btk::operator!= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___b_t_k_common.html#ga465dc77180b2b2d82fd4dfa9c5c432ba">btkNullPtr</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___b_t_k_common.html#ga4241aaaa133a08648262c931ee93c244">btkSharedPtr</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Inequality operator to test if a (const) shared pointer is null or not. </p>
<dl class="section note"><dt>Note</dt><dd>It is not advised to use this implementation of the operator. In pratice it will requires the instantiante a <a class="el" href="classbtk_1_1_null_ptr.html" title="To simplify the API when testing a shared pointer to know if it is null or not. ">NullPtr</a> object which will be then copied by reference.</dd></dl>
<p><b>Example</b> </p>
<div class="fragment"><div class="line">* <span class="comment">// Variable an is a btk::Analog::(Const)Pointer object.</span></div>
<div class="line">* <span class="comment">// A btk::NullPtr object is instanciated in the following condition.</span></div>
<div class="line">* <span class="keywordflow">if</span> (<a class="code" href="classbtk_1_1_analog.html#abe399efd10662c3a8812ab5b644dbb23">btk::Analog::Null</a>() != an)</div>
<div class="line">* {</div>
<div class="line">*   <span class="comment">// Do whatever</span></div>
<div class="line">* }</div>
<div class="line">* </div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ga7ca0455126f3ac35b05daeedd53d8f82"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool btk::operator!= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___b_t_k_common.html#ga465dc77180b2b2d82fd4dfa9c5c432ba">btkNullPtr</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___b_t_k_common.html#ga4241aaaa133a08648262c931ee93c244">btkSharedPtr</a>&lt; const T &gt;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Inequality operator to test if a (const) shared pointer is null or not. </p>
<dl class="section note"><dt>Note</dt><dd>It is not advised to use this implementation of the operator. In pratice it will requires the instantiante a <a class="el" href="classbtk_1_1_null_ptr.html" title="To simplify the API when testing a shared pointer to know if it is null or not. ">NullPtr</a> object which will be then copied by reference.</dd></dl>
<p><b>Example</b> </p>
<div class="fragment"><div class="line">* <span class="comment">// Variable an is a btk::Analog::(Const)Pointer object.</span></div>
<div class="line">* <span class="comment">// A btk::NullPtr object is instanciated in the following condition.</span></div>
<div class="line">* <span class="keywordflow">if</span> (<a class="code" href="classbtk_1_1_analog.html#abe399efd10662c3a8812ab5b644dbb23">btk::Analog::Null</a>() != an)</div>
<div class="line">* {</div>
<div class="line">*   <span class="comment">// Do whatever</span></div>
<div class="line">* }</div>
<div class="line">* </div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ga7ab39d9d0c20cddaa605da19f50e3bea"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool btk::operator!= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___b_t_k_common.html#ga4241aaaa133a08648262c931ee93c244">btkSharedPtr</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___b_t_k_common.html#ga465dc77180b2b2d82fd4dfa9c5c432ba">btkNullPtr</a>&lt; T &gt;(*)()&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Inequality operator to test if a (const) shared pointer is null or not.</p>
<p><b>Example</b> </p>
<div class="fragment"><div class="line">* <span class="comment">// Variable an is a btk::Analog::(Const)Pointer object.</span></div>
<div class="line">* <span class="comment">// No btk::NullPtr object is instanciated in the following condition.</span></div>
<div class="line">* <span class="keywordflow">if</span> (an != <a class="code" href="classbtk_1_1_analog.html#abe399efd10662c3a8812ab5b644dbb23">btk::Analog::Null</a>)</div>
<div class="line">* {</div>
<div class="line">*   <span class="comment">// Do whatever</span></div>
<div class="line">* }</div>
<div class="line">* </div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="gabc6f359814ba9a1f16fbf34190c5ce3b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool btk::operator!= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___b_t_k_common.html#ga4241aaaa133a08648262c931ee93c244">btkSharedPtr</a>&lt; const T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___b_t_k_common.html#ga465dc77180b2b2d82fd4dfa9c5c432ba">btkNullPtr</a>&lt; T &gt;(*)()&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Inequality operator to test if a (const) shared pointer is null or not.</p>
<p><b>Example</b> </p>
<div class="fragment"><div class="line">* <span class="comment">// Variable an is a btk::Analog::(Const)Pointer object.</span></div>
<div class="line">* <span class="comment">// No btk::NullPtr object is instanciated in the following condition.</span></div>
<div class="line">* <span class="keywordflow">if</span> (an != <a class="code" href="classbtk_1_1_analog.html#abe399efd10662c3a8812ab5b644dbb23">btk::Analog::Null</a>)</div>
<div class="line">* {</div>
<div class="line">*   <span class="comment">// Do whatever</span></div>
<div class="line">* }</div>
<div class="line">* </div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ga4fb0fb6fcc2e9c21943571abc044be8f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool btk::operator!= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___b_t_k_common.html#ga465dc77180b2b2d82fd4dfa9c5c432ba">btkNullPtr</a>&lt; T &gt;(*)()&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___b_t_k_common.html#ga4241aaaa133a08648262c931ee93c244">btkSharedPtr</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Inequality operator to test if a (const) shared pointer is null or not.</p>
<p><b>Example</b> </p>
<div class="fragment"><div class="line">* <span class="comment">// Variable an is a btk::Analog::(Const)Pointer object.</span></div>
<div class="line">* <span class="comment">// No btk::NullPtr object is instanciated in the following condition.</span></div>
<div class="line">* <span class="keywordflow">if</span> (<a class="code" href="classbtk_1_1_analog.html#abe399efd10662c3a8812ab5b644dbb23">btk::Analog::Null</a> != an)</div>
<div class="line">* {</div>
<div class="line">*   <span class="comment">// Do whatever</span></div>
<div class="line">* }</div>
<div class="line">* </div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ga236283ff8d7b3a50114ae223ad7aa2d0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool btk::operator!= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___b_t_k_common.html#ga465dc77180b2b2d82fd4dfa9c5c432ba">btkNullPtr</a>&lt; T &gt;(*)()&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___b_t_k_common.html#ga4241aaaa133a08648262c931ee93c244">btkSharedPtr</a>&lt; const T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Inequality operator to test if a (const) shared pointer is null or not.</p>
<p><b>Example</b> </p>
<div class="fragment"><div class="line">* <span class="comment">// Variable an is a btk::Analog::(Const)Pointer object.</span></div>
<div class="line">* <span class="comment">// No btk::NullPtr object is instanciated in the following condition.</span></div>
<div class="line">* <span class="keywordflow">if</span> (<a class="code" href="classbtk_1_1_analog.html#abe399efd10662c3a8812ab5b644dbb23">btk::Analog::Null</a> != an)</div>
<div class="line">* {</div>
<div class="line">*   <span class="comment">// Do whatever</span></div>
<div class="line">* }</div>
<div class="line">* </div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ga6477c68c6db116817e81e712b812a441"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool btk::operator== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___b_t_k_common.html#ga4241aaaa133a08648262c931ee93c244">btkSharedPtr</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___b_t_k_common.html#ga465dc77180b2b2d82fd4dfa9c5c432ba">btkNullPtr</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Equality operator to test if a (const) shared pointer is null or not. </p>
<dl class="section note"><dt>Note</dt><dd>It is not advised to use this implementation of the operator. In pratice it will requires the instantiante a <a class="el" href="classbtk_1_1_null_ptr.html" title="To simplify the API when testing a shared pointer to know if it is null or not. ">NullPtr</a> object which will be then copied by reference.</dd></dl>
<p><b>Example</b> </p>
<div class="fragment"><div class="line">* <span class="comment">// Variable an is a btk::Analog::(Const)Pointer object.</span></div>
<div class="line">* <span class="comment">// A btk::NullPtr object is instanciated in the following condition.</span></div>
<div class="line">* <span class="keywordflow">if</span> (an == <a class="code" href="classbtk_1_1_analog.html#abe399efd10662c3a8812ab5b644dbb23">btk::Analog::Null</a>())</div>
<div class="line">* {</div>
<div class="line">*   <span class="comment">// Do whatever</span></div>
<div class="line">* }</div>
<div class="line">* </div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ga5cebe736dd71aee9002ba3910564a808"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool btk::operator== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___b_t_k_common.html#ga4241aaaa133a08648262c931ee93c244">btkSharedPtr</a>&lt; const T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___b_t_k_common.html#ga465dc77180b2b2d82fd4dfa9c5c432ba">btkNullPtr</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Equality operator to test if a (const) shared pointer is null or not. </p>
<dl class="section note"><dt>Note</dt><dd>It is not advised to use this implementation of the operator. In pratice it will requires the instantiante a <a class="el" href="classbtk_1_1_null_ptr.html" title="To simplify the API when testing a shared pointer to know if it is null or not. ">NullPtr</a> object which will be then copied by reference.</dd></dl>
<p><b>Example</b> </p>
<div class="fragment"><div class="line">* <span class="comment">// Variable an is a btk::Analog::(Const)Pointer object.</span></div>
<div class="line">* <span class="comment">// A btk::NullPtr object is instanciated in the following condition.</span></div>
<div class="line">* <span class="keywordflow">if</span> (an == <a class="code" href="classbtk_1_1_analog.html#abe399efd10662c3a8812ab5b644dbb23">btk::Analog::Null</a>())</div>
<div class="line">* {</div>
<div class="line">*   <span class="comment">// Do whatever</span></div>
<div class="line">* }</div>
<div class="line">* </div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="gae150981a1edb4168ca00e9ef63592e91"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool btk::operator== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___b_t_k_common.html#ga465dc77180b2b2d82fd4dfa9c5c432ba">btkNullPtr</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___b_t_k_common.html#ga4241aaaa133a08648262c931ee93c244">btkSharedPtr</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Equality operator to test if a (const) shared pointer is null or not. </p>
<dl class="section note"><dt>Note</dt><dd>It is not advised to use this implementation of the operator. In pratice it will requires the instantiante a <a class="el" href="classbtk_1_1_null_ptr.html" title="To simplify the API when testing a shared pointer to know if it is null or not. ">NullPtr</a> object which will be then copied by reference.</dd></dl>
<p><b>Example</b> </p>
<div class="fragment"><div class="line">* <span class="comment">// Variable an is a btk::Analog::(Const)Pointer object.</span></div>
<div class="line">* <span class="comment">// A btk::NullPtr object is instanciated in the following condition.</span></div>
<div class="line">* <span class="keywordflow">if</span> (<a class="code" href="classbtk_1_1_analog.html#abe399efd10662c3a8812ab5b644dbb23">btk::Analog::Null</a>() == an)</div>
<div class="line">* {</div>
<div class="line">*   <span class="comment">// Do whatever</span></div>
<div class="line">* }</div>
<div class="line">* </div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ga8d84f90773c5f8b7e8ebbc286145b5d2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool btk::operator== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___b_t_k_common.html#ga465dc77180b2b2d82fd4dfa9c5c432ba">btkNullPtr</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___b_t_k_common.html#ga4241aaaa133a08648262c931ee93c244">btkSharedPtr</a>&lt; const T &gt;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Equality operator to test if a (const) shared pointer is null or not. </p>
<dl class="section note"><dt>Note</dt><dd>It is not advised to use this implementation of the operator. In pratice it will requires the instantiante a <a class="el" href="classbtk_1_1_null_ptr.html" title="To simplify the API when testing a shared pointer to know if it is null or not. ">NullPtr</a> object which will be then copied by reference.</dd></dl>
<p><b>Example</b> </p>
<div class="fragment"><div class="line">* <span class="comment">// Variable an is a btk::Analog::(Const)Pointer object.</span></div>
<div class="line">* <span class="comment">// A btk::NullPtr object is instanciated in the following condition.</span></div>
<div class="line">* <span class="keywordflow">if</span> (<a class="code" href="classbtk_1_1_analog.html#abe399efd10662c3a8812ab5b644dbb23">btk::Analog::Null</a>() == an)</div>
<div class="line">* {</div>
<div class="line">*   <span class="comment">// Do whatever</span></div>
<div class="line">* }</div>
<div class="line">* </div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="gaa723ed699aa58738bdaee59b8a7089c7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool btk::operator== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___b_t_k_common.html#ga4241aaaa133a08648262c931ee93c244">btkSharedPtr</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___b_t_k_common.html#ga465dc77180b2b2d82fd4dfa9c5c432ba">btkNullPtr</a>&lt; T &gt;(*)()&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Equality operator to test if a (const) shared pointer is null or not.</p>
<p><b>Example</b> </p>
<div class="fragment"><div class="line">* <span class="comment">// Variable an is a btk::Analog::(Const)Pointer object.</span></div>
<div class="line">* <span class="comment">// No btk::NullPtr object is instanciated in the following condition.</span></div>
<div class="line">* <span class="keywordflow">if</span> (an == <a class="code" href="classbtk_1_1_analog.html#abe399efd10662c3a8812ab5b644dbb23">btk::Analog::Null</a>)</div>
<div class="line">* {</div>
<div class="line">*   <span class="comment">// Do whatever</span></div>
<div class="line">* }</div>
<div class="line">* </div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ga11c1078a7443d8cbbb84e7d35b9cf236"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool btk::operator== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___b_t_k_common.html#ga4241aaaa133a08648262c931ee93c244">btkSharedPtr</a>&lt; const T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___b_t_k_common.html#ga465dc77180b2b2d82fd4dfa9c5c432ba">btkNullPtr</a>&lt; T &gt;(*)()&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Equality operator to test if a (const) shared pointer is null or not.</p>
<p><b>Example</b> </p>
<div class="fragment"><div class="line">* <span class="comment">// Variable an is a btk::Analog::(Const)Pointer object.</span></div>
<div class="line">* <span class="comment">// No btk::NullPtr object is instanciated in the following condition.</span></div>
<div class="line">* <span class="keywordflow">if</span> (an == <a class="code" href="classbtk_1_1_analog.html#abe399efd10662c3a8812ab5b644dbb23">btk::Analog::Null</a>)</div>
<div class="line">* {</div>
<div class="line">*   <span class="comment">// Do whatever</span></div>
<div class="line">* }</div>
<div class="line">* </div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ga588d95f0fb9b62f2be6a928c49bf6edc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool btk::operator== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___b_t_k_common.html#ga465dc77180b2b2d82fd4dfa9c5c432ba">btkNullPtr</a>&lt; T &gt;(*)()&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___b_t_k_common.html#ga4241aaaa133a08648262c931ee93c244">btkSharedPtr</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Equality operator to test if a (const) shared pointer is null or not.</p>
<p><b>Example</b> </p>
<div class="fragment"><div class="line">* <span class="comment">// Variable an is a btk::Analog::(Const)Pointer object.</span></div>
<div class="line">* <span class="comment">// No btk::NullPtr object is instanciated in the following condition.</span></div>
<div class="line">* <span class="keywordflow">if</span> (<a class="code" href="classbtk_1_1_analog.html#abe399efd10662c3a8812ab5b644dbb23">btk::Analog::Null</a> == an)</div>
<div class="line">* {</div>
<div class="line">*   <span class="comment">// Do whatever</span></div>
<div class="line">* }</div>
<div class="line">* </div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="gab599363aabad55119b01299c598d486b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool btk::operator== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___b_t_k_common.html#ga465dc77180b2b2d82fd4dfa9c5c432ba">btkNullPtr</a>&lt; T &gt;(*)()&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___b_t_k_common.html#ga4241aaaa133a08648262c931ee93c244">btkSharedPtr</a>&lt; const T &gt;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Equality operator to test if a (const) shared pointer is null or not.</p>
<p><b>Example</b> </p>
<div class="fragment"><div class="line">* <span class="comment">// Variable an is a btk::Analog::(Const)Pointer object.</span></div>
<div class="line">* <span class="comment">// No btk::NullPtr object is instanciated in the following condition.</span></div>
<div class="line">* <span class="keywordflow">if</span> (<a class="code" href="classbtk_1_1_analog.html#abe399efd10662c3a8812ab5b644dbb23">btk::Analog::Null</a> == an)</div>
<div class="line">* {</div>
<div class="line">*   <span class="comment">// Do whatever</span></div>
<div class="line">* }</div>
<div class="line">* </div>
</div><!-- fragment --> 
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Dec 27 2013 23:58:45 for BTK by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.5
</small></address>
</body>
</html>

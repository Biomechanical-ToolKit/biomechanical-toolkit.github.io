<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>BTK Python wrapper: Getting started</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="DoxygenStyleSheet_Python.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">BTK Python wrapper
   &#160;<span id="projectnumber">0.3dev.0</span>
   </div>
   <div id="projectbrief">Python bindings for the Biomechanical ToolKit library (BTK)</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Packages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Getting started </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><div class="btkmenu"><a class="el" href="index.html">Overview</a> | <a class="el" href="_build_instructions.html">Building instructions</a> | <b>Getting</b> <b>started</b> | <a class="el" href="_more_tutorials.html">More Tutorials</a> | <a class="el" href="_license.html">License</a> </div><p>The following list gives you the steps to use BTK in a Python environment.</p>
<ul>
<li><a class="el" href="_getting_started.html#TutorialIntroPython">Why a python implementation?</a></li>
<li><a class="el" href="_getting_started.html#TutorialGettingStarted">Getting started</a></li>
<li><a class="el" href="_getting_started.html#TutorialProcessingData">Process data</a></li>
</ul>
 <hr> <p>Note: A special thanks to Fabien Leboeuf (<a href="http://www.chu-nantes.fr/laboratoire-d-analyse-du-mouvement-26629.kjsp?RH=1201612496535">Laboratoire du Mouvement</a>, CHU Nantes) who wrote the original version of this tutorial.</p>
<h1><a class="anchor" id="TutorialIntroPython"></a>
Why a python implementation?</h1>
<p>Python is a high-level language, free to use, running on diï¬€erent environments (Windows, Linux, MacOS X). It favours the object-oriented programming, which do not prevent to implement functional programming. The syntax is clear, doing python easy to learn and faster to develop. The popularity of Python increases in the scientific community. Indeed, lot of libraries can respond to any scientifical expectations (signal processing (Scipy) , 3D modelisation (pyVtk) , optimization (pyOpt), etc). Moreover, advanced interactive- development environment, like spyder (see figure below), appears allowing to easily switch from Matlab.</p>
<div class="image">
<img src="scipy-spyder.jpg" alt="scipy-spyder.jpg"/>
<div class="caption">
Screenshot of the software Spyder: Scientific PYthon Development EnviRonment</div></div>
<p> For further informations about Python versus matlab comparison, you can read this <a href="http://sites.google.com/site/pythonforscientists/python-vs-matlab">article</a>.</p>
<h1><a class="anchor" id="TutorialGettingStarted"></a>
Getting started</h1>
<h2><a class="anchor" id="TutorialPythonAddPackage"></a>
Add the package btk in Python</h2>
<p>If you put the two files (btk.py and btk.pyd (Windows), btk.so (Linux/MacOS X)) in the working directory, you only have to add the following code: <code>import btk</code> in you script header.<br/>
 Otherwise, if the package is located in another folder then you need to add the path in the known path by Python. </p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;import sys</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;sys.path.append(<span class="stringliteral">&quot;path of btk python package&quot;</span>)</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;<span class="keyword">import</span> btk</div>
</div><!-- fragment --><p> Note: if you use Spyder, you can add interactively this path by using the menu <code>Tools &gt; PYTHONPATH manager</code>.</p>
<p>The command <code>import btk</code> creates the namespace <code>btk</code> which have to be specified as a prefix if you create a new BTK object. As an example, a new reader acquisition object will be built with: </p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;reader = <a class="code" href="classbtk_1_1btk_acquisition_file_reader.html">btk.btkAcquisitionFileReader</a>()</div>
</div><!-- fragment --><h1><a class="anchor" id="TutorialAcquisitionExplained"></a>
Enjoy with a c3d acquisition file</h1>
<p>The primary advantage of BTK is to oï¬€er lots of methods for handling a motion capture file, especially the C3D extension. This binary file embeds four containers:</p>
<ul>
<li>3D POINT represents all vectors, like marker coordinates or any biomechanical paremeters (euler/cardan angles, joint forces and moments, etc);</li>
<li>ANALOG (1D signal) inherents to sensors plugged into the analog to digital converter (muscular sensors, accelerometers, etc);</li>
<li>EVENT represents a specific frame of the movement;</li>
<li>METADATA is a generic container containing all relevant informations about the subject, the system configuration, etc.</li>
</ul>
<h2><a class="anchor" id="TutorialPythonReadAcquisition"></a>
Read an aquisition</h2>
<p>Reading an acquisition is simple. </p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;reader = <a class="code" href="classbtk_1_1btk_acquisition_file_reader.html">btk.btkAcquisitionFileReader</a>() <span class="comment"># build a btk reader object</span></div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;reader.SetFilename(<span class="stringliteral">&quot;dynamic.c3d&quot;</span>) <span class="comment"># set a filename to the reader</span></div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;reader.Update()</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;acq = reader.GetOutput() <span class="comment"># acq is the btk aquisition object</span></div>
</div><!-- fragment --><p> The output is the BTK-aquisition objet <code>acq</code> on which you can use diï¬€erent accessors for exploring and setting data.</p>
<h2><a class="anchor" id="TutorialPythonExploreAcquisition"></a>
Explore an acquisition</h2>
<h3><a class="anchor" id="TutorialPythonPoint"></a>
Point object</h3>
<p>First of all, BTK prevents to extract point frame number and point-aquisition frequency from the metadata. Special accessors are proposed: </p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;acq.GetPointFrequency() <span class="comment"># give the point frequency</span></div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;acq.GetPointFrameNumber() <span class="comment"># give the number of frames</span></div>
</div><!-- fragment --><p> Now, letâ€™s imagine that your acquisition only contains the points named into the acquisition:</p>
<ul>
<li><em>LASI:</em> the cartesian coordinates of a marker placed on the Left Antero-Superior Iliac spine ;</li>
<li><em>LKneeAngles</em> : the knee joint coordinate angles.</li>
</ul>
<p>You can extract them from the aquisition object <code>acq</code> with these methods: </p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;point1 = acq.GetPoint(<span class="stringliteral">&quot;LASI&quot;</span>)</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;point2 = acq.GetPoint(<span class="stringliteral">&quot;LKneeAngles&quot;</span>)</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;<span class="comment">#if you rather prefer handle index instead of point name, you can use</span></div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;point1 = acq.GetPoint(0)</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;point2 = acq.GetPoint(1)</div>
</div><!-- fragment --><p> Then <em>point1</em> is the BTK-object characterizing the LASI marker. To access to its 3d-values: </p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;values = point1.GetValues() <span class="comment"># return a Numpy array of nrows, and 3 columns</span></div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;<span class="comment"># for slicing the previous Numpy Array, you can use</span></div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;point1.GetValues()[0,0] <span class="comment"># return the value of the first row, first column.</span></div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;point1.GetValues()[:,0] <span class="comment"># extract the first column</span></div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;point1.GetValue(0,0) <span class="comment"># another method for extracting the first row, first col</span></div>
</div><!-- fragment --><p> Except that the index begins at 0, accessing to element of a numpy array is similar to the matlab syntax. For help about Numpy slicing and equivalent matlab functions, you can read the following user guide <a href="http://www.scipy.org/NumPy_for_Matlab_Users">Numpy for Matlab Users</a>.</p>
<h3><a class="anchor" id="TutorialPythonAnalog"></a>
Analog object</h3>
<p>Extracting analog object is similar to point extraction. Generally, analog measures are acquired at high-speed frequency. This parameter can be accessed with the method <code>btkAcquisiton::GetAnalogFrequency()</code> as the number of frame with the accessors <code>btkAcquisition::GetAnalogFrameNumber()</code>. Imagine that the c3d contains the muscular activities labeled: Emg1, Emg2, Emg3,... The following code will explain how to extract their values: </p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;analog1 = acq.GetAnalog(<span class="stringliteral">&quot;Emg1&quot;</span>) <span class="comment"># attribute a btk-analog object to the measurement</span></div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;values = analog1.GetValues() <span class="comment"># return a 1D Numpy array</span></div>
</div><!-- fragment --><h3><a class="anchor" id="TutorialPythonEvent"></a>
Event</h3>
<p>An event extracts from the aquisition with the method <code>btkAcquisition::GetEvent()</code>. This creates the BTK-object event of which main features are:</p>
<ul>
<li>Label: the name of the event</li>
<li>Context: indicates if the event is general or attributed to the left (right) body side</li>
<li>Frame: the the frame where the event occurs</li>
</ul>
<p>Accessing to these informations is easy with the method <code>btkEvent::GetLabel</code>, <code>btkEvent::GetContext</code>, <code>btkEvent::GetFrame</code>. As an example: </p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;event = acq.GetEvent(0) <span class="comment"># extract the first event of the aquisition</span></div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;event.GetLabel() <span class="comment"># return a string representing the Label</span></div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;event.GetContext() <span class="comment"># return a string representing the Context</span></div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;event.GetFrame() <span class="comment"># return the frame as an integer</span></div>
</div><!-- fragment --><h3><a class="anchor" id="TutorialPythonMetadata"></a>
Metadata</h3>
<p>To access the metadata, you have to use the method <code>btkAcquisition::GetMetaData()</code> on the BTK-acquisition object <code>acq</code>. A metadata represents a tree structure as in the figure below.</p>
<div class="image">
<img src="mokka-metadata.png" alt="mokka-metadata.png"/>
<div class="caption">
Dialog window from the software Mokka showing the metadata of an acquisition.</div></div>
<p>To extract the content of the metada <code>POINT:MOVIE_DELAY</code>, you can do it as following </p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;metadata = acq.GetMetaData()</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;delay = metadata.FindChild(<span class="stringliteral">&quot;POINT&quot;</span>).value().FindChild(<span class="stringliteral">&quot;MOVIE_DELAY&quot;</span>).value().GetInfo().toDouble()</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;<span class="comment"># return a Tuple of double.</span></div>
</div><!-- fragment --><h2><a class="anchor" id="TutorialPythonModyAcquisition"></a>
Modify an acquisition</h2>
<p>Writing data into an acquisition is as easy as reading data. The package proposed dedicated methods to do it directly on an aquisition object.</p>
<h3><a class="anchor" id="TutorialPythonModifyPoint"></a>
Modify and append a point</h3>
<p>The following code firsly explains how to modify one point value. Secondly, a new point will be appended into the acquisition. In this case, developpers can use diï¬€erent signatures to build a new <code>btkpoint</code> object. In this example two signatures are illustrated. Others are detailed in the Doxygen help (see documentation of the class btkPoint). </p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;point1 = acq.GetPoint(<span class="stringliteral">&quot;LASI&quot;</span>)</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;<span class="comment"># 1) Modifying an element (first raw and first column)</span></div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;point1.SetValue(0,0,1000.0) <span class="comment"># the new coordinate is to 1000</span></div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;<span class="comment"># 2) Appending a new point</span></div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;newValue = numpy.ones(acq.GetPointFrameNumber(),3) <span class="comment"># identity numpy array with 3 colum and PointFrameNumber rows.</span></div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;<span class="comment"># minimal signature = indicate the number of point frame</span></div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;newpoint = <a class="code" href="classbtk_1_1btk_point.html">btk.btkPoint</a>(acq.GetPointFrameNumber()) <span class="comment"># create an empty new point object</span></div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;newpoint.SetLabel(â ™newPointâ€™) # set newPoint as label
newpoint.SetValues(newValue) # set the value
acq.AppendPoint(newpoint) # append the new point into the acquisition object
# other possible siganture
# =&gt; the new point is automatically built with the label &quot;newPointShort&quot;
newpoint_short = btk.btkPoint(â€™newPointShortâ€™, acq.GetPointFrameNumber())
newpoint_short.SetValues(value)€ newPointâ€™) # set newPoint as label
newpoint.SetValues(newValue) # set the value
acq.AppendPoint(newpoint) # append the new point into the acquisition object
# other possible siganture
# =&gt; the new point is automatically built with the label &quot;newPointShort&quot;
newpoint_short = btk.btkPoint(â€™newPointShortâ€™, acq.GetPointFrameNumber())
newpoint_short.SetValues(value)™ ewPointâ€™) # set newPoint as label
newpoint.SetValues(newValue) # set the value
acq.AppendPoint(newpoint) # append the new point into the acquisition object
# other possible siganture
# =&gt; the new point is automatically built with the label &quot;newPointShort&quot;
newpoint_short = btk.btkPoint(â€™newPointShortâ€™, acq.GetPointFrameNumber())
newpoint_short.SetValues(value)newPointâ ™) # set newPoint as label
newpoint.SetValues(newValue) # set the value
acq.AppendPoint(newpoint) # append the new point into the acquisition object
# other possible siganture
# =&gt; the new point is automatically built with the label &quot;newPointShort&quot;
newpoint_short = btk.btkPoint(â€™newPointShortâ€™, acq.GetPointFrameNumber())
newpoint_short.SetValues(value)€ ) # set newPoint as label
newpoint.SetValues(newValue) # set the value
acq.AppendPoint(newpoint) # append the new point into the acquisition object
# other possible siganture
# =&gt; the new point is automatically built with the label &quot;newPointShort&quot;
newpoint_short = btk.btkPoint(â€™newPointShortâ€™, acq.GetPointFrameNumber())
newpoint_short.SetValues(value)™  # set newPoint as label
newpoint.SetValues(newValue) # set the value
acq.AppendPoint(newpoint) # append the new point into the acquisition object
# other possible siganture
# =&gt; the new point is automatically built with the label &quot;newPointShort&quot;
newpoint_short = btk.btkPoint(â€™newPointShortâ€™, acq.GetPointFrameNumber())
newpoint_short.SetValues(value)) <span class="comment"># set newPoint as label</span></div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;newpoint.SetValues(newValue) <span class="comment"># set the value</span></div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;acq.AppendPoint(newpoint) <span class="comment"># append the new point into the acquisition object</span></div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;<span class="comment"># other possible siganture</span></div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;<span class="comment"># =&gt; the new point is automatically built with the label &quot;newPointShort&quot;</span></div>
<div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;newpoint_short = <a class="code" href="classbtk_1_1btk_point.html">btk.btkPoint</a>(â ™newPointShortâ€™, acq.GetPointFrameNumber())
newpoint_short.SetValues(value)€ newPointShortâ€™, acq.GetPointFrameNumber())
newpoint_short.SetValues(value)™ ewPointShortâ€™, acq.GetPointFrameNumber())
newpoint_short.SetValues(value)newPointShortâ ™, acq.GetPointFrameNumber())
newpoint_short.SetValues(value)€ , acq.GetPointFrameNumber())
newpoint_short.SetValues(value)™  acq.GetPointFrameNumber())
newpoint_short.SetValues(value), acq.GetPointFrameNumber())</div>
<div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;newpoint_short.SetValues(value)</div>
</div><!-- fragment --><h3><a class="anchor" id="TutorialPythonModifyAnalog"></a>
Modify and append and analog channel</h3>
<p>The syntax is equivalent to the above point section. </p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;<span class="comment"># 1) modifying an element</span></div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;analog1 = acq.GetAnalog(<span class="stringliteral">&quot;Emg1&quot;</span>) <span class="comment"># extract the analog channel Emg1</span></div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;analog1.SetValue(0,1000.0) <span class="comment"># modifiy the first value</span></div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;<span class="comment"># 2) appending a new analog signal</span></div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;newValueAnalog = np.ones( (acq.GetAnalogFrameNumber(),1)) <span class="comment"># identity numpy array with 1 column and AnalogFrameNumber rows.</span></div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;newAnalog=<a class="code" href="classbtk_1_1btk_analog.html">btk.btkAnalog</a>(acq.GetAnalogFrameNumber()) <span class="comment"># create an empty new analog channel</span></div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;newAnalog.SetValues(newValueAnalog) <span class="comment"># set its values</span></div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;newAnalog.SetLabel(<span class="stringliteral">&quot;NewAnalog&quot;</span>) <span class="comment"># set its label</span></div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;acq.AppendAnalog(newAnalog) <span class="comment"># append the new analog object to the aquisition</span></div>
</div><!-- fragment --><h3><a class="anchor" id="TutorialPythonModifyEvent"></a>
Modify and append an event</h3>
<p>If you want to change features of the first event, you can use </p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;event=acq.GetEvent(0) <span class="comment"># extract the first event of the aquisition</span></div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;event.SetLabel(<span class="stringliteral">&quot;Foot off&quot;</span>) <span class="comment"># replace the label</span></div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;event.SetContext(<span class="stringliteral">&quot;general&quot;</span>)</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;event.SetFrame(25)</div>
</div><!-- fragment --><p> Appending a new event to the aquisition is possible with following script: </p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;newEvent=<a class="code" href="classbtk_1_1btk_event.html">btk.btkEvent</a>() <span class="comment"># build an empty event object</span></div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;newEvent.SetLabel(<span class="stringliteral">&quot;Foot Off&quot;</span>) <span class="comment"># set the label</span></div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;newEvent.SetContext(<span class="stringliteral">&quot;Left&quot;</span>) <span class="comment">#</span></div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;newEvent.SetFrame(390)</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;acq.AppendEvent(newEvent) <span class="comment"># append the new event to the aquisition object</span></div>
</div><!-- fragment --><h3><a class="anchor" id="TutorialPythonModifyMetadata"></a>
Modify metadata</h3>
<p>To modify the value of the metadata MOVIE_DELAY: </p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;metadata = acq.GetMetaData()</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;<span class="comment"># access a spÂ´ecific element</span></div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;MOVIE_DELAY = metadata.FindChild(â ™POINTâ€™).value().FindChild(â€™MOVIE_DELAYâ€™).value().GetInfo()
MOVIE_DELAY.SetValue(0,2) #setting the first element with the value 2€ POINTâ€™).value().FindChild(â€™MOVIE_DELAYâ€™).value().GetInfo()
MOVIE_DELAY.SetValue(0,2) #setting the first element with the value 2™ OINTâ€™).value().FindChild(â€™MOVIE_DELAYâ€™).value().GetInfo()
MOVIE_DELAY.SetValue(0,2) #setting the first element with the value 2POINTâ ™).value().FindChild(â€™MOVIE_DELAYâ€™).value().GetInfo()
MOVIE_DELAY.SetValue(0,2) #setting the first element with the value 2€ ).value().FindChild(â€™MOVIE_DELAYâ€™).value().GetInfo()
MOVIE_DELAY.SetValue(0,2) #setting the first element with the value 2™ .value().FindChild(â€™MOVIE_DELAYâ€™).value().GetInfo()
MOVIE_DELAY.SetValue(0,2) #setting the first element with the value 2).value().FindChild(â ™MOVIE_DELAYâ€™).value().GetInfo()
MOVIE_DELAY.SetValue(0,2) #setting the first element with the value 2€ MOVIE_DELAYâ€™).value().GetInfo()
MOVIE_DELAY.SetValue(0,2) #setting the first element with the value 2™ OVIE_DELAYâ€™).value().GetInfo()
MOVIE_DELAY.SetValue(0,2) #setting the first element with the value 2MOVIE_DELAYâ ™).value().GetInfo()
MOVIE_DELAY.SetValue(0,2) #setting the first element with the value 2€ ).value().GetInfo()
MOVIE_DELAY.SetValue(0,2) #setting the first element with the value 2™ .value().GetInfo()
MOVIE_DELAY.SetValue(0,2) #setting the first element with the value 2).value().GetInfo()</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;MOVIE_DELAY.SetValue(0,2) <span class="comment">#setting the first element with the value 2</span></div>
</div><!-- fragment --><h2><a class="anchor" id="TutorialPythonRecord"></a>
Recording a c3d with the modification</h2>
<p>All modifications are definitely recorded into a C3D file ONLY IF the following lines end your script. This code consists in building a <code>btkAcquisitionFileWriter</code> object and linking it to the modified acquisition. The method <code>btkAcquisitionFileWriter::SetFilename</code> allows you either to overwrite the existing file or to create a new one. </p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;writer = <a class="code" href="classbtk_1_1btk_acquisition_file_writer.html">btk.btkAcquisitionFileWriter</a>()</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;writer.SetInput(acq)</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;writer.SetFilename(â ™newFile.c3dâ€™)
writer.Update()€ newFile.c3dâ€™)
writer.Update()™ ewFile.c3dâ€™)
writer.Update()newFile.c3dâ ™)
writer.Update()€ )
writer.Update()™ 
writer.Update())</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;writer.Update()</div>
</div><!-- fragment --><h1><a class="anchor" id="TutorialProcessingData"></a>
Process data</h1>
<p>With Python language, one interest of BTK is to take advantage of scipy modules to implement biomechanical processes.</p>
<h2><a class="anchor" id="TutorialPythonFilterData"></a>
Filter data</h2>
<p>An unavoidable process is to filter the data. To this end, the module <code>scipy.signal</code> presents a large panel of filtering methods, with a syntax close to Matlab. For example, this code show how to filter an analog data with a Butterworth filter.</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;<span class="comment"># modules to import</span></div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;<span class="keyword">import</span> os</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;<span class="keyword">import</span> sys</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;<span class="keyword">import</span> btk</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;<span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;<span class="keyword">import</span> numpy <span class="keyword">as</span> np</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;<span class="keyword">import</span> scipy.signal</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;<span class="comment"># Raw data represent the analog measures labelled Emg1 into the c3d</span></div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;analog1 = acq.GetAnalog(<span class="stringliteral">&quot;Emg1&quot;</span>)</div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;RawValue = analogs1.GetValues()</div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;<span class="comment"># Application of a 4-order low-pass Butterworth filter with a frequency set at 9 Hz</span></div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;<span class="comment"># use of the module Scipy/signal</span></div>
<div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;order = 4</div>
<div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;Fc = 9</div>
<div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;b, a = scipy.signal.butter(order, fc/(0.5*acq.GetAnalogFrequency()))</div>
<div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;FilteringData = scipy.signal.filtfilt(b, a,RawValue[:,0])</div>
<div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;<span class="comment"># plotting data (use of the library matplotlib, prefixed here by plt)</span></div>
<div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;plt.figure() <span class="comment">#create figure</span></div>
<div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;plt.plot(RawValue) <span class="comment"># plot raw data</span></div>
<div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;plt.plot(FilteringData) <span class="comment"># plot filtering data</span></div>
<div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;plt.show()</div>
</div><!-- fragment --><h2><a class="anchor" id="TutorialPythonComputeFrame"></a>
Compute reference frame from markers</h2>
<p>The second biomechanical process takes as example show how to find the nearest rotation matrix from the movement of the pelvis cluster, according Challis, 1995 (<em>A procedure for determining rigid body transformation parameters</em>, Journal of Biomechanics, 28(6), pp. 733-737). The code manipulates method associated with a numpy array object and used the linear algebra module of Scipy.</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;<span class="comment"># modules to import</span></div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;<span class="keyword">import</span> os</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;<span class="keyword">import</span> btk</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;<span class="keyword">import</span> numpy <span class="keyword">as</span> np</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;<span class="keyword">import</span> scipy.linalg</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;<span class="comment"># Creation of an numpy array for the referencial frame and the chosen frame</span></div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;<span class="comment"># each row is the X,Y, Z coordinates of the one pelvis marker at the reference frame</span></div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;data_FrameRef = np.array([acq.GetPoint(â ™LASIâ€™).GetValues()[0,:],
                          acq.GetPoint(â€™RASIâ€™).GetValues()[0,:],
                          acq.GetPoint(â€™LPSIâ€™).GetValues()[0,:],
                          acq.GetPoint(â€™RPSIâ€™).GetValues()[0,:]])
Frame = 40
data_FrameChosen = np.array([acq.GetPoint(â€™LASIâ€™).GetValues()[Frame,:],
                             acq.GetPoint(â€™RASIâ€™).GetValues()[Frame,:],
                             acq.GetPoint(â€™LPSIâ€™).GetValues()[Frame,:],
                             acq.GetPoint(â€™RPSIâ€™).GetValues()[Frame,:]])
# Difference with mean values
A = data_FrameRef-np.mean(data_FrameRef,axis=0)
B = data_FrameChosen-np.mean(data_FrameChosen,axis=0)
# transposition of the data
A = A.transpose()
B = B.transpose()
# matrix multiplication
# (Note : with a numpy array, itâ€™s the dot method, not the multiplication operator)
C = np.dot(B,A.transpose())
# singular decomposition, called the svd method of the scipy/linalg module
P,T,Q = scipy.linalg.svd(C)
# computation of the nearest rotation matrix R
mat = np.array([[ 1., 0., 0.],
                [ 0., 1., 0.],
                [ 0., 0., scipy.linalg.det(np.dot(P,Q.transpose()))]])
R = np.dot(P,np.dot(mat,Q.transpose()))€ LASIâ€™).GetValues()[0,:],
                          acq.GetPoint(â€™RASIâ€™).GetValues()[0,:],
                          acq.GetPoint(â€™LPSIâ€™).GetValues()[0,:],
                          acq.GetPoint(â€™RPSIâ€™).GetValues()[0,:]])
Frame = 40
data_FrameChosen = np.array([acq.GetPoint(â€™LASIâ€™).GetValues()[Frame,:],
                             acq.GetPoint(â€™RASIâ€™).GetValues()[Frame,:],
                             acq.GetPoint(â€™LPSIâ€™).GetValues()[Frame,:],
                             acq.GetPoint(â€™RPSIâ€™).GetValues()[Frame,:]])
# Difference with mean values
A = data_FrameRef-np.mean(data_FrameRef,axis=0)
B = data_FrameChosen-np.mean(data_FrameChosen,axis=0)
# transposition of the data
A = A.transpose()
B = B.transpose()
# matrix multiplication
# (Note : with a numpy array, itâ€™s the dot method, not the multiplication operator)
C = np.dot(B,A.transpose())
# singular decomposition, called the svd method of the scipy/linalg module
P,T,Q = scipy.linalg.svd(C)
# computation of the nearest rotation matrix R
mat = np.array([[ 1., 0., 0.],
                [ 0., 1., 0.],
                [ 0., 0., scipy.linalg.det(np.dot(P,Q.transpose()))]])
R = np.dot(P,np.dot(mat,Q.transpose()))™ ASIâ€™).GetValues()[0,:],
                          acq.GetPoint(â€™RASIâ€™).GetValues()[0,:],
                          acq.GetPoint(â€™LPSIâ€™).GetValues()[0,:],
                          acq.GetPoint(â€™RPSIâ€™).GetValues()[0,:]])
Frame = 40
data_FrameChosen = np.array([acq.GetPoint(â€™LASIâ€™).GetValues()[Frame,:],
                             acq.GetPoint(â€™RASIâ€™).GetValues()[Frame,:],
                             acq.GetPoint(â€™LPSIâ€™).GetValues()[Frame,:],
                             acq.GetPoint(â€™RPSIâ€™).GetValues()[Frame,:]])
# Difference with mean values
A = data_FrameRef-np.mean(data_FrameRef,axis=0)
B = data_FrameChosen-np.mean(data_FrameChosen,axis=0)
# transposition of the data
A = A.transpose()
B = B.transpose()
# matrix multiplication
# (Note : with a numpy array, itâ€™s the dot method, not the multiplication operator)
C = np.dot(B,A.transpose())
# singular decomposition, called the svd method of the scipy/linalg module
P,T,Q = scipy.linalg.svd(C)
# computation of the nearest rotation matrix R
mat = np.array([[ 1., 0., 0.],
                [ 0., 1., 0.],
                [ 0., 0., scipy.linalg.det(np.dot(P,Q.transpose()))]])
R = np.dot(P,np.dot(mat,Q.transpose()))LASIâ ™).GetValues()[0,:],
                          acq.GetPoint(â€™RASIâ€™).GetValues()[0,:],
                          acq.GetPoint(â€™LPSIâ€™).GetValues()[0,:],
                          acq.GetPoint(â€™RPSIâ€™).GetValues()[0,:]])
Frame = 40
data_FrameChosen = np.array([acq.GetPoint(â€™LASIâ€™).GetValues()[Frame,:],
                             acq.GetPoint(â€™RASIâ€™).GetValues()[Frame,:],
                             acq.GetPoint(â€™LPSIâ€™).GetValues()[Frame,:],
                             acq.GetPoint(â€™RPSIâ€™).GetValues()[Frame,:]])
# Difference with mean values
A = data_FrameRef-np.mean(data_FrameRef,axis=0)
B = data_FrameChosen-np.mean(data_FrameChosen,axis=0)
# transposition of the data
A = A.transpose()
B = B.transpose()
# matrix multiplication
# (Note : with a numpy array, itâ€™s the dot method, not the multiplication operator)
C = np.dot(B,A.transpose())
# singular decomposition, called the svd method of the scipy/linalg module
P,T,Q = scipy.linalg.svd(C)
# computation of the nearest rotation matrix R
mat = np.array([[ 1., 0., 0.],
                [ 0., 1., 0.],
                [ 0., 0., scipy.linalg.det(np.dot(P,Q.transpose()))]])
R = np.dot(P,np.dot(mat,Q.transpose()))€ ).GetValues()[0,:],
                          acq.GetPoint(â€™RASIâ€™).GetValues()[0,:],
                          acq.GetPoint(â€™LPSIâ€™).GetValues()[0,:],
                          acq.GetPoint(â€™RPSIâ€™).GetValues()[0,:]])
Frame = 40
data_FrameChosen = np.array([acq.GetPoint(â€™LASIâ€™).GetValues()[Frame,:],
                             acq.GetPoint(â€™RASIâ€™).GetValues()[Frame,:],
                             acq.GetPoint(â€™LPSIâ€™).GetValues()[Frame,:],
                             acq.GetPoint(â€™RPSIâ€™).GetValues()[Frame,:]])
# Difference with mean values
A = data_FrameRef-np.mean(data_FrameRef,axis=0)
B = data_FrameChosen-np.mean(data_FrameChosen,axis=0)
# transposition of the data
A = A.transpose()
B = B.transpose()
# matrix multiplication
# (Note : with a numpy array, itâ€™s the dot method, not the multiplication operator)
C = np.dot(B,A.transpose())
# singular decomposition, called the svd method of the scipy/linalg module
P,T,Q = scipy.linalg.svd(C)
# computation of the nearest rotation matrix R
mat = np.array([[ 1., 0., 0.],
                [ 0., 1., 0.],
                [ 0., 0., scipy.linalg.det(np.dot(P,Q.transpose()))]])
R = np.dot(P,np.dot(mat,Q.transpose()))™ .GetValues()[0,:],
                          acq.GetPoint(â€™RASIâ€™).GetValues()[0,:],
                          acq.GetPoint(â€™LPSIâ€™).GetValues()[0,:],
                          acq.GetPoint(â€™RPSIâ€™).GetValues()[0,:]])
Frame = 40
data_FrameChosen = np.array([acq.GetPoint(â€™LASIâ€™).GetValues()[Frame,:],
                             acq.GetPoint(â€™RASIâ€™).GetValues()[Frame,:],
                             acq.GetPoint(â€™LPSIâ€™).GetValues()[Frame,:],
                             acq.GetPoint(â€™RPSIâ€™).GetValues()[Frame,:]])
# Difference with mean values
A = data_FrameRef-np.mean(data_FrameRef,axis=0)
B = data_FrameChosen-np.mean(data_FrameChosen,axis=0)
# transposition of the data
A = A.transpose()
B = B.transpose()
# matrix multiplication
# (Note : with a numpy array, itâ€™s the dot method, not the multiplication operator)
C = np.dot(B,A.transpose())
# singular decomposition, called the svd method of the scipy/linalg module
P,T,Q = scipy.linalg.svd(C)
# computation of the nearest rotation matrix R
mat = np.array([[ 1., 0., 0.],
                [ 0., 1., 0.],
                [ 0., 0., scipy.linalg.det(np.dot(P,Q.transpose()))]])
R = np.dot(P,np.dot(mat,Q.transpose()))).GetValues()[0,:],</div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;                          acq.GetPoint(â ™RASIâ€™).GetValues()[0,:],
                          acq.GetPoint(â€™LPSIâ€™).GetValues()[0,:],
                          acq.GetPoint(â€™RPSIâ€™).GetValues()[0,:]])
Frame = 40
data_FrameChosen = np.array([acq.GetPoint(â€™LASIâ€™).GetValues()[Frame,:],
                             acq.GetPoint(â€™RASIâ€™).GetValues()[Frame,:],
                             acq.GetPoint(â€™LPSIâ€™).GetValues()[Frame,:],
                             acq.GetPoint(â€™RPSIâ€™).GetValues()[Frame,:]])
# Difference with mean values
A = data_FrameRef-np.mean(data_FrameRef,axis=0)
B = data_FrameChosen-np.mean(data_FrameChosen,axis=0)
# transposition of the data
A = A.transpose()
B = B.transpose()
# matrix multiplication
# (Note : with a numpy array, itâ€™s the dot method, not the multiplication operator)
C = np.dot(B,A.transpose())
# singular decomposition, called the svd method of the scipy/linalg module
P,T,Q = scipy.linalg.svd(C)
# computation of the nearest rotation matrix R
mat = np.array([[ 1., 0., 0.],
                [ 0., 1., 0.],
                [ 0., 0., scipy.linalg.det(np.dot(P,Q.transpose()))]])
R = np.dot(P,np.dot(mat,Q.transpose()))€ RASIâ€™).GetValues()[0,:],
                          acq.GetPoint(â€™LPSIâ€™).GetValues()[0,:],
                          acq.GetPoint(â€™RPSIâ€™).GetValues()[0,:]])
Frame = 40
data_FrameChosen = np.array([acq.GetPoint(â€™LASIâ€™).GetValues()[Frame,:],
                             acq.GetPoint(â€™RASIâ€™).GetValues()[Frame,:],
                             acq.GetPoint(â€™LPSIâ€™).GetValues()[Frame,:],
                             acq.GetPoint(â€™RPSIâ€™).GetValues()[Frame,:]])
# Difference with mean values
A = data_FrameRef-np.mean(data_FrameRef,axis=0)
B = data_FrameChosen-np.mean(data_FrameChosen,axis=0)
# transposition of the data
A = A.transpose()
B = B.transpose()
# matrix multiplication
# (Note : with a numpy array, itâ€™s the dot method, not the multiplication operator)
C = np.dot(B,A.transpose())
# singular decomposition, called the svd method of the scipy/linalg module
P,T,Q = scipy.linalg.svd(C)
# computation of the nearest rotation matrix R
mat = np.array([[ 1., 0., 0.],
                [ 0., 1., 0.],
                [ 0., 0., scipy.linalg.det(np.dot(P,Q.transpose()))]])
R = np.dot(P,np.dot(mat,Q.transpose()))™ ASIâ€™).GetValues()[0,:],
                          acq.GetPoint(â€™LPSIâ€™).GetValues()[0,:],
                          acq.GetPoint(â€™RPSIâ€™).GetValues()[0,:]])
Frame = 40
data_FrameChosen = np.array([acq.GetPoint(â€™LASIâ€™).GetValues()[Frame,:],
                             acq.GetPoint(â€™RASIâ€™).GetValues()[Frame,:],
                             acq.GetPoint(â€™LPSIâ€™).GetValues()[Frame,:],
                             acq.GetPoint(â€™RPSIâ€™).GetValues()[Frame,:]])
# Difference with mean values
A = data_FrameRef-np.mean(data_FrameRef,axis=0)
B = data_FrameChosen-np.mean(data_FrameChosen,axis=0)
# transposition of the data
A = A.transpose()
B = B.transpose()
# matrix multiplication
# (Note : with a numpy array, itâ€™s the dot method, not the multiplication operator)
C = np.dot(B,A.transpose())
# singular decomposition, called the svd method of the scipy/linalg module
P,T,Q = scipy.linalg.svd(C)
# computation of the nearest rotation matrix R
mat = np.array([[ 1., 0., 0.],
                [ 0., 1., 0.],
                [ 0., 0., scipy.linalg.det(np.dot(P,Q.transpose()))]])
R = np.dot(P,np.dot(mat,Q.transpose()))RASIâ ™).GetValues()[0,:],
                          acq.GetPoint(â€™LPSIâ€™).GetValues()[0,:],
                          acq.GetPoint(â€™RPSIâ€™).GetValues()[0,:]])
Frame = 40
data_FrameChosen = np.array([acq.GetPoint(â€™LASIâ€™).GetValues()[Frame,:],
                             acq.GetPoint(â€™RASIâ€™).GetValues()[Frame,:],
                             acq.GetPoint(â€™LPSIâ€™).GetValues()[Frame,:],
                             acq.GetPoint(â€™RPSIâ€™).GetValues()[Frame,:]])
# Difference with mean values
A = data_FrameRef-np.mean(data_FrameRef,axis=0)
B = data_FrameChosen-np.mean(data_FrameChosen,axis=0)
# transposition of the data
A = A.transpose()
B = B.transpose()
# matrix multiplication
# (Note : with a numpy array, itâ€™s the dot method, not the multiplication operator)
C = np.dot(B,A.transpose())
# singular decomposition, called the svd method of the scipy/linalg module
P,T,Q = scipy.linalg.svd(C)
# computation of the nearest rotation matrix R
mat = np.array([[ 1., 0., 0.],
                [ 0., 1., 0.],
                [ 0., 0., scipy.linalg.det(np.dot(P,Q.transpose()))]])
R = np.dot(P,np.dot(mat,Q.transpose()))€ ).GetValues()[0,:],
                          acq.GetPoint(â€™LPSIâ€™).GetValues()[0,:],
                          acq.GetPoint(â€™RPSIâ€™).GetValues()[0,:]])
Frame = 40
data_FrameChosen = np.array([acq.GetPoint(â€™LASIâ€™).GetValues()[Frame,:],
                             acq.GetPoint(â€™RASIâ€™).GetValues()[Frame,:],
                             acq.GetPoint(â€™LPSIâ€™).GetValues()[Frame,:],
                             acq.GetPoint(â€™RPSIâ€™).GetValues()[Frame,:]])
# Difference with mean values
A = data_FrameRef-np.mean(data_FrameRef,axis=0)
B = data_FrameChosen-np.mean(data_FrameChosen,axis=0)
# transposition of the data
A = A.transpose()
B = B.transpose()
# matrix multiplication
# (Note : with a numpy array, itâ€™s the dot method, not the multiplication operator)
C = np.dot(B,A.transpose())
# singular decomposition, called the svd method of the scipy/linalg module
P,T,Q = scipy.linalg.svd(C)
# computation of the nearest rotation matrix R
mat = np.array([[ 1., 0., 0.],
                [ 0., 1., 0.],
                [ 0., 0., scipy.linalg.det(np.dot(P,Q.transpose()))]])
R = np.dot(P,np.dot(mat,Q.transpose()))™ .GetValues()[0,:],
                          acq.GetPoint(â€™LPSIâ€™).GetValues()[0,:],
                          acq.GetPoint(â€™RPSIâ€™).GetValues()[0,:]])
Frame = 40
data_FrameChosen = np.array([acq.GetPoint(â€™LASIâ€™).GetValues()[Frame,:],
                             acq.GetPoint(â€™RASIâ€™).GetValues()[Frame,:],
                             acq.GetPoint(â€™LPSIâ€™).GetValues()[Frame,:],
                             acq.GetPoint(â€™RPSIâ€™).GetValues()[Frame,:]])
# Difference with mean values
A = data_FrameRef-np.mean(data_FrameRef,axis=0)
B = data_FrameChosen-np.mean(data_FrameChosen,axis=0)
# transposition of the data
A = A.transpose()
B = B.transpose()
# matrix multiplication
# (Note : with a numpy array, itâ€™s the dot method, not the multiplication operator)
C = np.dot(B,A.transpose())
# singular decomposition, called the svd method of the scipy/linalg module
P,T,Q = scipy.linalg.svd(C)
# computation of the nearest rotation matrix R
mat = np.array([[ 1., 0., 0.],
                [ 0., 1., 0.],
                [ 0., 0., scipy.linalg.det(np.dot(P,Q.transpose()))]])
R = np.dot(P,np.dot(mat,Q.transpose()))).GetValues()[0,:],</div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;                          acq.GetPoint(â ™LPSIâ€™).GetValues()[0,:],
                          acq.GetPoint(â€™RPSIâ€™).GetValues()[0,:]])
Frame = 40
data_FrameChosen = np.array([acq.GetPoint(â€™LASIâ€™).GetValues()[Frame,:],
                             acq.GetPoint(â€™RASIâ€™).GetValues()[Frame,:],
                             acq.GetPoint(â€™LPSIâ€™).GetValues()[Frame,:],
                             acq.GetPoint(â€™RPSIâ€™).GetValues()[Frame,:]])
# Difference with mean values
A = data_FrameRef-np.mean(data_FrameRef,axis=0)
B = data_FrameChosen-np.mean(data_FrameChosen,axis=0)
# transposition of the data
A = A.transpose()
B = B.transpose()
# matrix multiplication
# (Note : with a numpy array, itâ€™s the dot method, not the multiplication operator)
C = np.dot(B,A.transpose())
# singular decomposition, called the svd method of the scipy/linalg module
P,T,Q = scipy.linalg.svd(C)
# computation of the nearest rotation matrix R
mat = np.array([[ 1., 0., 0.],
                [ 0., 1., 0.],
                [ 0., 0., scipy.linalg.det(np.dot(P,Q.transpose()))]])
R = np.dot(P,np.dot(mat,Q.transpose()))€ LPSIâ€™).GetValues()[0,:],
                          acq.GetPoint(â€™RPSIâ€™).GetValues()[0,:]])
Frame = 40
data_FrameChosen = np.array([acq.GetPoint(â€™LASIâ€™).GetValues()[Frame,:],
                             acq.GetPoint(â€™RASIâ€™).GetValues()[Frame,:],
                             acq.GetPoint(â€™LPSIâ€™).GetValues()[Frame,:],
                             acq.GetPoint(â€™RPSIâ€™).GetValues()[Frame,:]])
# Difference with mean values
A = data_FrameRef-np.mean(data_FrameRef,axis=0)
B = data_FrameChosen-np.mean(data_FrameChosen,axis=0)
# transposition of the data
A = A.transpose()
B = B.transpose()
# matrix multiplication
# (Note : with a numpy array, itâ€™s the dot method, not the multiplication operator)
C = np.dot(B,A.transpose())
# singular decomposition, called the svd method of the scipy/linalg module
P,T,Q = scipy.linalg.svd(C)
# computation of the nearest rotation matrix R
mat = np.array([[ 1., 0., 0.],
                [ 0., 1., 0.],
                [ 0., 0., scipy.linalg.det(np.dot(P,Q.transpose()))]])
R = np.dot(P,np.dot(mat,Q.transpose()))™ PSIâ€™).GetValues()[0,:],
                          acq.GetPoint(â€™RPSIâ€™).GetValues()[0,:]])
Frame = 40
data_FrameChosen = np.array([acq.GetPoint(â€™LASIâ€™).GetValues()[Frame,:],
                             acq.GetPoint(â€™RASIâ€™).GetValues()[Frame,:],
                             acq.GetPoint(â€™LPSIâ€™).GetValues()[Frame,:],
                             acq.GetPoint(â€™RPSIâ€™).GetValues()[Frame,:]])
# Difference with mean values
A = data_FrameRef-np.mean(data_FrameRef,axis=0)
B = data_FrameChosen-np.mean(data_FrameChosen,axis=0)
# transposition of the data
A = A.transpose()
B = B.transpose()
# matrix multiplication
# (Note : with a numpy array, itâ€™s the dot method, not the multiplication operator)
C = np.dot(B,A.transpose())
# singular decomposition, called the svd method of the scipy/linalg module
P,T,Q = scipy.linalg.svd(C)
# computation of the nearest rotation matrix R
mat = np.array([[ 1., 0., 0.],
                [ 0., 1., 0.],
                [ 0., 0., scipy.linalg.det(np.dot(P,Q.transpose()))]])
R = np.dot(P,np.dot(mat,Q.transpose()))LPSIâ ™).GetValues()[0,:],
                          acq.GetPoint(â€™RPSIâ€™).GetValues()[0,:]])
Frame = 40
data_FrameChosen = np.array([acq.GetPoint(â€™LASIâ€™).GetValues()[Frame,:],
                             acq.GetPoint(â€™RASIâ€™).GetValues()[Frame,:],
                             acq.GetPoint(â€™LPSIâ€™).GetValues()[Frame,:],
                             acq.GetPoint(â€™RPSIâ€™).GetValues()[Frame,:]])
# Difference with mean values
A = data_FrameRef-np.mean(data_FrameRef,axis=0)
B = data_FrameChosen-np.mean(data_FrameChosen,axis=0)
# transposition of the data
A = A.transpose()
B = B.transpose()
# matrix multiplication
# (Note : with a numpy array, itâ€™s the dot method, not the multiplication operator)
C = np.dot(B,A.transpose())
# singular decomposition, called the svd method of the scipy/linalg module
P,T,Q = scipy.linalg.svd(C)
# computation of the nearest rotation matrix R
mat = np.array([[ 1., 0., 0.],
                [ 0., 1., 0.],
                [ 0., 0., scipy.linalg.det(np.dot(P,Q.transpose()))]])
R = np.dot(P,np.dot(mat,Q.transpose()))€ ).GetValues()[0,:],
                          acq.GetPoint(â€™RPSIâ€™).GetValues()[0,:]])
Frame = 40
data_FrameChosen = np.array([acq.GetPoint(â€™LASIâ€™).GetValues()[Frame,:],
                             acq.GetPoint(â€™RASIâ€™).GetValues()[Frame,:],
                             acq.GetPoint(â€™LPSIâ€™).GetValues()[Frame,:],
                             acq.GetPoint(â€™RPSIâ€™).GetValues()[Frame,:]])
# Difference with mean values
A = data_FrameRef-np.mean(data_FrameRef,axis=0)
B = data_FrameChosen-np.mean(data_FrameChosen,axis=0)
# transposition of the data
A = A.transpose()
B = B.transpose()
# matrix multiplication
# (Note : with a numpy array, itâ€™s the dot method, not the multiplication operator)
C = np.dot(B,A.transpose())
# singular decomposition, called the svd method of the scipy/linalg module
P,T,Q = scipy.linalg.svd(C)
# computation of the nearest rotation matrix R
mat = np.array([[ 1., 0., 0.],
                [ 0., 1., 0.],
                [ 0., 0., scipy.linalg.det(np.dot(P,Q.transpose()))]])
R = np.dot(P,np.dot(mat,Q.transpose()))™ .GetValues()[0,:],
                          acq.GetPoint(â€™RPSIâ€™).GetValues()[0,:]])
Frame = 40
data_FrameChosen = np.array([acq.GetPoint(â€™LASIâ€™).GetValues()[Frame,:],
                             acq.GetPoint(â€™RASIâ€™).GetValues()[Frame,:],
                             acq.GetPoint(â€™LPSIâ€™).GetValues()[Frame,:],
                             acq.GetPoint(â€™RPSIâ€™).GetValues()[Frame,:]])
# Difference with mean values
A = data_FrameRef-np.mean(data_FrameRef,axis=0)
B = data_FrameChosen-np.mean(data_FrameChosen,axis=0)
# transposition of the data
A = A.transpose()
B = B.transpose()
# matrix multiplication
# (Note : with a numpy array, itâ€™s the dot method, not the multiplication operator)
C = np.dot(B,A.transpose())
# singular decomposition, called the svd method of the scipy/linalg module
P,T,Q = scipy.linalg.svd(C)
# computation of the nearest rotation matrix R
mat = np.array([[ 1., 0., 0.],
                [ 0., 1., 0.],
                [ 0., 0., scipy.linalg.det(np.dot(P,Q.transpose()))]])
R = np.dot(P,np.dot(mat,Q.transpose()))).GetValues()[0,:],</div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;                          acq.GetPoint(â ™RPSIâ€™).GetValues()[0,:]])
Frame = 40
data_FrameChosen = np.array([acq.GetPoint(â€™LASIâ€™).GetValues()[Frame,:],
                             acq.GetPoint(â€™RASIâ€™).GetValues()[Frame,:],
                             acq.GetPoint(â€™LPSIâ€™).GetValues()[Frame,:],
                             acq.GetPoint(â€™RPSIâ€™).GetValues()[Frame,:]])
# Difference with mean values
A = data_FrameRef-np.mean(data_FrameRef,axis=0)
B = data_FrameChosen-np.mean(data_FrameChosen,axis=0)
# transposition of the data
A = A.transpose()
B = B.transpose()
# matrix multiplication
# (Note : with a numpy array, itâ€™s the dot method, not the multiplication operator)
C = np.dot(B,A.transpose())
# singular decomposition, called the svd method of the scipy/linalg module
P,T,Q = scipy.linalg.svd(C)
# computation of the nearest rotation matrix R
mat = np.array([[ 1., 0., 0.],
                [ 0., 1., 0.],
                [ 0., 0., scipy.linalg.det(np.dot(P,Q.transpose()))]])
R = np.dot(P,np.dot(mat,Q.transpose()))€ RPSIâ€™).GetValues()[0,:]])
Frame = 40
data_FrameChosen = np.array([acq.GetPoint(â€™LASIâ€™).GetValues()[Frame,:],
                             acq.GetPoint(â€™RASIâ€™).GetValues()[Frame,:],
                             acq.GetPoint(â€™LPSIâ€™).GetValues()[Frame,:],
                             acq.GetPoint(â€™RPSIâ€™).GetValues()[Frame,:]])
# Difference with mean values
A = data_FrameRef-np.mean(data_FrameRef,axis=0)
B = data_FrameChosen-np.mean(data_FrameChosen,axis=0)
# transposition of the data
A = A.transpose()
B = B.transpose()
# matrix multiplication
# (Note : with a numpy array, itâ€™s the dot method, not the multiplication operator)
C = np.dot(B,A.transpose())
# singular decomposition, called the svd method of the scipy/linalg module
P,T,Q = scipy.linalg.svd(C)
# computation of the nearest rotation matrix R
mat = np.array([[ 1., 0., 0.],
                [ 0., 1., 0.],
                [ 0., 0., scipy.linalg.det(np.dot(P,Q.transpose()))]])
R = np.dot(P,np.dot(mat,Q.transpose()))™ PSIâ€™).GetValues()[0,:]])
Frame = 40
data_FrameChosen = np.array([acq.GetPoint(â€™LASIâ€™).GetValues()[Frame,:],
                             acq.GetPoint(â€™RASIâ€™).GetValues()[Frame,:],
                             acq.GetPoint(â€™LPSIâ€™).GetValues()[Frame,:],
                             acq.GetPoint(â€™RPSIâ€™).GetValues()[Frame,:]])
# Difference with mean values
A = data_FrameRef-np.mean(data_FrameRef,axis=0)
B = data_FrameChosen-np.mean(data_FrameChosen,axis=0)
# transposition of the data
A = A.transpose()
B = B.transpose()
# matrix multiplication
# (Note : with a numpy array, itâ€™s the dot method, not the multiplication operator)
C = np.dot(B,A.transpose())
# singular decomposition, called the svd method of the scipy/linalg module
P,T,Q = scipy.linalg.svd(C)
# computation of the nearest rotation matrix R
mat = np.array([[ 1., 0., 0.],
                [ 0., 1., 0.],
                [ 0., 0., scipy.linalg.det(np.dot(P,Q.transpose()))]])
R = np.dot(P,np.dot(mat,Q.transpose()))RPSIâ ™).GetValues()[0,:]])
Frame = 40
data_FrameChosen = np.array([acq.GetPoint(â€™LASIâ€™).GetValues()[Frame,:],
                             acq.GetPoint(â€™RASIâ€™).GetValues()[Frame,:],
                             acq.GetPoint(â€™LPSIâ€™).GetValues()[Frame,:],
                             acq.GetPoint(â€™RPSIâ€™).GetValues()[Frame,:]])
# Difference with mean values
A = data_FrameRef-np.mean(data_FrameRef,axis=0)
B = data_FrameChosen-np.mean(data_FrameChosen,axis=0)
# transposition of the data
A = A.transpose()
B = B.transpose()
# matrix multiplication
# (Note : with a numpy array, itâ€™s the dot method, not the multiplication operator)
C = np.dot(B,A.transpose())
# singular decomposition, called the svd method of the scipy/linalg module
P,T,Q = scipy.linalg.svd(C)
# computation of the nearest rotation matrix R
mat = np.array([[ 1., 0., 0.],
                [ 0., 1., 0.],
                [ 0., 0., scipy.linalg.det(np.dot(P,Q.transpose()))]])
R = np.dot(P,np.dot(mat,Q.transpose()))€ ).GetValues()[0,:]])
Frame = 40
data_FrameChosen = np.array([acq.GetPoint(â€™LASIâ€™).GetValues()[Frame,:],
                             acq.GetPoint(â€™RASIâ€™).GetValues()[Frame,:],
                             acq.GetPoint(â€™LPSIâ€™).GetValues()[Frame,:],
                             acq.GetPoint(â€™RPSIâ€™).GetValues()[Frame,:]])
# Difference with mean values
A = data_FrameRef-np.mean(data_FrameRef,axis=0)
B = data_FrameChosen-np.mean(data_FrameChosen,axis=0)
# transposition of the data
A = A.transpose()
B = B.transpose()
# matrix multiplication
# (Note : with a numpy array, itâ€™s the dot method, not the multiplication operator)
C = np.dot(B,A.transpose())
# singular decomposition, called the svd method of the scipy/linalg module
P,T,Q = scipy.linalg.svd(C)
# computation of the nearest rotation matrix R
mat = np.array([[ 1., 0., 0.],
                [ 0., 1., 0.],
                [ 0., 0., scipy.linalg.det(np.dot(P,Q.transpose()))]])
R = np.dot(P,np.dot(mat,Q.transpose()))™ .GetValues()[0,:]])
Frame = 40
data_FrameChosen = np.array([acq.GetPoint(â€™LASIâ€™).GetValues()[Frame,:],
                             acq.GetPoint(â€™RASIâ€™).GetValues()[Frame,:],
                             acq.GetPoint(â€™LPSIâ€™).GetValues()[Frame,:],
                             acq.GetPoint(â€™RPSIâ€™).GetValues()[Frame,:]])
# Difference with mean values
A = data_FrameRef-np.mean(data_FrameRef,axis=0)
B = data_FrameChosen-np.mean(data_FrameChosen,axis=0)
# transposition of the data
A = A.transpose()
B = B.transpose()
# matrix multiplication
# (Note : with a numpy array, itâ€™s the dot method, not the multiplication operator)
C = np.dot(B,A.transpose())
# singular decomposition, called the svd method of the scipy/linalg module
P,T,Q = scipy.linalg.svd(C)
# computation of the nearest rotation matrix R
mat = np.array([[ 1., 0., 0.],
                [ 0., 1., 0.],
                [ 0., 0., scipy.linalg.det(np.dot(P,Q.transpose()))]])
R = np.dot(P,np.dot(mat,Q.transpose()))).GetValues()[0,:]])</div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;Frame = 40</div>
<div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;data_FrameChosen = np.array([acq.GetPoint(â ™LASIâ€™).GetValues()[Frame,:],
                             acq.GetPoint(â€™RASIâ€™).GetValues()[Frame,:],
                             acq.GetPoint(â€™LPSIâ€™).GetValues()[Frame,:],
                             acq.GetPoint(â€™RPSIâ€™).GetValues()[Frame,:]])
# Difference with mean values
A = data_FrameRef-np.mean(data_FrameRef,axis=0)
B = data_FrameChosen-np.mean(data_FrameChosen,axis=0)
# transposition of the data
A = A.transpose()
B = B.transpose()
# matrix multiplication
# (Note : with a numpy array, itâ€™s the dot method, not the multiplication operator)
C = np.dot(B,A.transpose())
# singular decomposition, called the svd method of the scipy/linalg module
P,T,Q = scipy.linalg.svd(C)
# computation of the nearest rotation matrix R
mat = np.array([[ 1., 0., 0.],
                [ 0., 1., 0.],
                [ 0., 0., scipy.linalg.det(np.dot(P,Q.transpose()))]])
R = np.dot(P,np.dot(mat,Q.transpose()))€ LASIâ€™).GetValues()[Frame,:],
                             acq.GetPoint(â€™RASIâ€™).GetValues()[Frame,:],
                             acq.GetPoint(â€™LPSIâ€™).GetValues()[Frame,:],
                             acq.GetPoint(â€™RPSIâ€™).GetValues()[Frame,:]])
# Difference with mean values
A = data_FrameRef-np.mean(data_FrameRef,axis=0)
B = data_FrameChosen-np.mean(data_FrameChosen,axis=0)
# transposition of the data
A = A.transpose()
B = B.transpose()
# matrix multiplication
# (Note : with a numpy array, itâ€™s the dot method, not the multiplication operator)
C = np.dot(B,A.transpose())
# singular decomposition, called the svd method of the scipy/linalg module
P,T,Q = scipy.linalg.svd(C)
# computation of the nearest rotation matrix R
mat = np.array([[ 1., 0., 0.],
                [ 0., 1., 0.],
                [ 0., 0., scipy.linalg.det(np.dot(P,Q.transpose()))]])
R = np.dot(P,np.dot(mat,Q.transpose()))™ ASIâ€™).GetValues()[Frame,:],
                             acq.GetPoint(â€™RASIâ€™).GetValues()[Frame,:],
                             acq.GetPoint(â€™LPSIâ€™).GetValues()[Frame,:],
                             acq.GetPoint(â€™RPSIâ€™).GetValues()[Frame,:]])
# Difference with mean values
A = data_FrameRef-np.mean(data_FrameRef,axis=0)
B = data_FrameChosen-np.mean(data_FrameChosen,axis=0)
# transposition of the data
A = A.transpose()
B = B.transpose()
# matrix multiplication
# (Note : with a numpy array, itâ€™s the dot method, not the multiplication operator)
C = np.dot(B,A.transpose())
# singular decomposition, called the svd method of the scipy/linalg module
P,T,Q = scipy.linalg.svd(C)
# computation of the nearest rotation matrix R
mat = np.array([[ 1., 0., 0.],
                [ 0., 1., 0.],
                [ 0., 0., scipy.linalg.det(np.dot(P,Q.transpose()))]])
R = np.dot(P,np.dot(mat,Q.transpose()))LASIâ ™).GetValues()[Frame,:],
                             acq.GetPoint(â€™RASIâ€™).GetValues()[Frame,:],
                             acq.GetPoint(â€™LPSIâ€™).GetValues()[Frame,:],
                             acq.GetPoint(â€™RPSIâ€™).GetValues()[Frame,:]])
# Difference with mean values
A = data_FrameRef-np.mean(data_FrameRef,axis=0)
B = data_FrameChosen-np.mean(data_FrameChosen,axis=0)
# transposition of the data
A = A.transpose()
B = B.transpose()
# matrix multiplication
# (Note : with a numpy array, itâ€™s the dot method, not the multiplication operator)
C = np.dot(B,A.transpose())
# singular decomposition, called the svd method of the scipy/linalg module
P,T,Q = scipy.linalg.svd(C)
# computation of the nearest rotation matrix R
mat = np.array([[ 1., 0., 0.],
                [ 0., 1., 0.],
                [ 0., 0., scipy.linalg.det(np.dot(P,Q.transpose()))]])
R = np.dot(P,np.dot(mat,Q.transpose()))€ ).GetValues()[Frame,:],
                             acq.GetPoint(â€™RASIâ€™).GetValues()[Frame,:],
                             acq.GetPoint(â€™LPSIâ€™).GetValues()[Frame,:],
                             acq.GetPoint(â€™RPSIâ€™).GetValues()[Frame,:]])
# Difference with mean values
A = data_FrameRef-np.mean(data_FrameRef,axis=0)
B = data_FrameChosen-np.mean(data_FrameChosen,axis=0)
# transposition of the data
A = A.transpose()
B = B.transpose()
# matrix multiplication
# (Note : with a numpy array, itâ€™s the dot method, not the multiplication operator)
C = np.dot(B,A.transpose())
# singular decomposition, called the svd method of the scipy/linalg module
P,T,Q = scipy.linalg.svd(C)
# computation of the nearest rotation matrix R
mat = np.array([[ 1., 0., 0.],
                [ 0., 1., 0.],
                [ 0., 0., scipy.linalg.det(np.dot(P,Q.transpose()))]])
R = np.dot(P,np.dot(mat,Q.transpose()))™ .GetValues()[Frame,:],
                             acq.GetPoint(â€™RASIâ€™).GetValues()[Frame,:],
                             acq.GetPoint(â€™LPSIâ€™).GetValues()[Frame,:],
                             acq.GetPoint(â€™RPSIâ€™).GetValues()[Frame,:]])
# Difference with mean values
A = data_FrameRef-np.mean(data_FrameRef,axis=0)
B = data_FrameChosen-np.mean(data_FrameChosen,axis=0)
# transposition of the data
A = A.transpose()
B = B.transpose()
# matrix multiplication
# (Note : with a numpy array, itâ€™s the dot method, not the multiplication operator)
C = np.dot(B,A.transpose())
# singular decomposition, called the svd method of the scipy/linalg module
P,T,Q = scipy.linalg.svd(C)
# computation of the nearest rotation matrix R
mat = np.array([[ 1., 0., 0.],
                [ 0., 1., 0.],
                [ 0., 0., scipy.linalg.det(np.dot(P,Q.transpose()))]])
R = np.dot(P,np.dot(mat,Q.transpose()))).GetValues()[Frame,:],</div>
<div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;                             acq.GetPoint(â ™RASIâ€™).GetValues()[Frame,:],
                             acq.GetPoint(â€™LPSIâ€™).GetValues()[Frame,:],
                             acq.GetPoint(â€™RPSIâ€™).GetValues()[Frame,:]])
# Difference with mean values
A = data_FrameRef-np.mean(data_FrameRef,axis=0)
B = data_FrameChosen-np.mean(data_FrameChosen,axis=0)
# transposition of the data
A = A.transpose()
B = B.transpose()
# matrix multiplication
# (Note : with a numpy array, itâ€™s the dot method, not the multiplication operator)
C = np.dot(B,A.transpose())
# singular decomposition, called the svd method of the scipy/linalg module
P,T,Q = scipy.linalg.svd(C)
# computation of the nearest rotation matrix R
mat = np.array([[ 1., 0., 0.],
                [ 0., 1., 0.],
                [ 0., 0., scipy.linalg.det(np.dot(P,Q.transpose()))]])
R = np.dot(P,np.dot(mat,Q.transpose()))€ RASIâ€™).GetValues()[Frame,:],
                             acq.GetPoint(â€™LPSIâ€™).GetValues()[Frame,:],
                             acq.GetPoint(â€™RPSIâ€™).GetValues()[Frame,:]])
# Difference with mean values
A = data_FrameRef-np.mean(data_FrameRef,axis=0)
B = data_FrameChosen-np.mean(data_FrameChosen,axis=0)
# transposition of the data
A = A.transpose()
B = B.transpose()
# matrix multiplication
# (Note : with a numpy array, itâ€™s the dot method, not the multiplication operator)
C = np.dot(B,A.transpose())
# singular decomposition, called the svd method of the scipy/linalg module
P,T,Q = scipy.linalg.svd(C)
# computation of the nearest rotation matrix R
mat = np.array([[ 1., 0., 0.],
                [ 0., 1., 0.],
                [ 0., 0., scipy.linalg.det(np.dot(P,Q.transpose()))]])
R = np.dot(P,np.dot(mat,Q.transpose()))™ ASIâ€™).GetValues()[Frame,:],
                             acq.GetPoint(â€™LPSIâ€™).GetValues()[Frame,:],
                             acq.GetPoint(â€™RPSIâ€™).GetValues()[Frame,:]])
# Difference with mean values
A = data_FrameRef-np.mean(data_FrameRef,axis=0)
B = data_FrameChosen-np.mean(data_FrameChosen,axis=0)
# transposition of the data
A = A.transpose()
B = B.transpose()
# matrix multiplication
# (Note : with a numpy array, itâ€™s the dot method, not the multiplication operator)
C = np.dot(B,A.transpose())
# singular decomposition, called the svd method of the scipy/linalg module
P,T,Q = scipy.linalg.svd(C)
# computation of the nearest rotation matrix R
mat = np.array([[ 1., 0., 0.],
                [ 0., 1., 0.],
                [ 0., 0., scipy.linalg.det(np.dot(P,Q.transpose()))]])
R = np.dot(P,np.dot(mat,Q.transpose()))RASIâ ™).GetValues()[Frame,:],
                             acq.GetPoint(â€™LPSIâ€™).GetValues()[Frame,:],
                             acq.GetPoint(â€™RPSIâ€™).GetValues()[Frame,:]])
# Difference with mean values
A = data_FrameRef-np.mean(data_FrameRef,axis=0)
B = data_FrameChosen-np.mean(data_FrameChosen,axis=0)
# transposition of the data
A = A.transpose()
B = B.transpose()
# matrix multiplication
# (Note : with a numpy array, itâ€™s the dot method, not the multiplication operator)
C = np.dot(B,A.transpose())
# singular decomposition, called the svd method of the scipy/linalg module
P,T,Q = scipy.linalg.svd(C)
# computation of the nearest rotation matrix R
mat = np.array([[ 1., 0., 0.],
                [ 0., 1., 0.],
                [ 0., 0., scipy.linalg.det(np.dot(P,Q.transpose()))]])
R = np.dot(P,np.dot(mat,Q.transpose()))€ ).GetValues()[Frame,:],
                             acq.GetPoint(â€™LPSIâ€™).GetValues()[Frame,:],
                             acq.GetPoint(â€™RPSIâ€™).GetValues()[Frame,:]])
# Difference with mean values
A = data_FrameRef-np.mean(data_FrameRef,axis=0)
B = data_FrameChosen-np.mean(data_FrameChosen,axis=0)
# transposition of the data
A = A.transpose()
B = B.transpose()
# matrix multiplication
# (Note : with a numpy array, itâ€™s the dot method, not the multiplication operator)
C = np.dot(B,A.transpose())
# singular decomposition, called the svd method of the scipy/linalg module
P,T,Q = scipy.linalg.svd(C)
# computation of the nearest rotation matrix R
mat = np.array([[ 1., 0., 0.],
                [ 0., 1., 0.],
                [ 0., 0., scipy.linalg.det(np.dot(P,Q.transpose()))]])
R = np.dot(P,np.dot(mat,Q.transpose()))™ .GetValues()[Frame,:],
                             acq.GetPoint(â€™LPSIâ€™).GetValues()[Frame,:],
                             acq.GetPoint(â€™RPSIâ€™).GetValues()[Frame,:]])
# Difference with mean values
A = data_FrameRef-np.mean(data_FrameRef,axis=0)
B = data_FrameChosen-np.mean(data_FrameChosen,axis=0)
# transposition of the data
A = A.transpose()
B = B.transpose()
# matrix multiplication
# (Note : with a numpy array, itâ€™s the dot method, not the multiplication operator)
C = np.dot(B,A.transpose())
# singular decomposition, called the svd method of the scipy/linalg module
P,T,Q = scipy.linalg.svd(C)
# computation of the nearest rotation matrix R
mat = np.array([[ 1., 0., 0.],
                [ 0., 1., 0.],
                [ 0., 0., scipy.linalg.det(np.dot(P,Q.transpose()))]])
R = np.dot(P,np.dot(mat,Q.transpose()))).GetValues()[Frame,:],</div>
<div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;                             acq.GetPoint(â ™LPSIâ€™).GetValues()[Frame,:],
                             acq.GetPoint(â€™RPSIâ€™).GetValues()[Frame,:]])
# Difference with mean values
A = data_FrameRef-np.mean(data_FrameRef,axis=0)
B = data_FrameChosen-np.mean(data_FrameChosen,axis=0)
# transposition of the data
A = A.transpose()
B = B.transpose()
# matrix multiplication
# (Note : with a numpy array, itâ€™s the dot method, not the multiplication operator)
C = np.dot(B,A.transpose())
# singular decomposition, called the svd method of the scipy/linalg module
P,T,Q = scipy.linalg.svd(C)
# computation of the nearest rotation matrix R
mat = np.array([[ 1., 0., 0.],
                [ 0., 1., 0.],
                [ 0., 0., scipy.linalg.det(np.dot(P,Q.transpose()))]])
R = np.dot(P,np.dot(mat,Q.transpose()))€ LPSIâ€™).GetValues()[Frame,:],
                             acq.GetPoint(â€™RPSIâ€™).GetValues()[Frame,:]])
# Difference with mean values
A = data_FrameRef-np.mean(data_FrameRef,axis=0)
B = data_FrameChosen-np.mean(data_FrameChosen,axis=0)
# transposition of the data
A = A.transpose()
B = B.transpose()
# matrix multiplication
# (Note : with a numpy array, itâ€™s the dot method, not the multiplication operator)
C = np.dot(B,A.transpose())
# singular decomposition, called the svd method of the scipy/linalg module
P,T,Q = scipy.linalg.svd(C)
# computation of the nearest rotation matrix R
mat = np.array([[ 1., 0., 0.],
                [ 0., 1., 0.],
                [ 0., 0., scipy.linalg.det(np.dot(P,Q.transpose()))]])
R = np.dot(P,np.dot(mat,Q.transpose()))™ PSIâ€™).GetValues()[Frame,:],
                             acq.GetPoint(â€™RPSIâ€™).GetValues()[Frame,:]])
# Difference with mean values
A = data_FrameRef-np.mean(data_FrameRef,axis=0)
B = data_FrameChosen-np.mean(data_FrameChosen,axis=0)
# transposition of the data
A = A.transpose()
B = B.transpose()
# matrix multiplication
# (Note : with a numpy array, itâ€™s the dot method, not the multiplication operator)
C = np.dot(B,A.transpose())
# singular decomposition, called the svd method of the scipy/linalg module
P,T,Q = scipy.linalg.svd(C)
# computation of the nearest rotation matrix R
mat = np.array([[ 1., 0., 0.],
                [ 0., 1., 0.],
                [ 0., 0., scipy.linalg.det(np.dot(P,Q.transpose()))]])
R = np.dot(P,np.dot(mat,Q.transpose()))LPSIâ ™).GetValues()[Frame,:],
                             acq.GetPoint(â€™RPSIâ€™).GetValues()[Frame,:]])
# Difference with mean values
A = data_FrameRef-np.mean(data_FrameRef,axis=0)
B = data_FrameChosen-np.mean(data_FrameChosen,axis=0)
# transposition of the data
A = A.transpose()
B = B.transpose()
# matrix multiplication
# (Note : with a numpy array, itâ€™s the dot method, not the multiplication operator)
C = np.dot(B,A.transpose())
# singular decomposition, called the svd method of the scipy/linalg module
P,T,Q = scipy.linalg.svd(C)
# computation of the nearest rotation matrix R
mat = np.array([[ 1., 0., 0.],
                [ 0., 1., 0.],
                [ 0., 0., scipy.linalg.det(np.dot(P,Q.transpose()))]])
R = np.dot(P,np.dot(mat,Q.transpose()))€ ).GetValues()[Frame,:],
                             acq.GetPoint(â€™RPSIâ€™).GetValues()[Frame,:]])
# Difference with mean values
A = data_FrameRef-np.mean(data_FrameRef,axis=0)
B = data_FrameChosen-np.mean(data_FrameChosen,axis=0)
# transposition of the data
A = A.transpose()
B = B.transpose()
# matrix multiplication
# (Note : with a numpy array, itâ€™s the dot method, not the multiplication operator)
C = np.dot(B,A.transpose())
# singular decomposition, called the svd method of the scipy/linalg module
P,T,Q = scipy.linalg.svd(C)
# computation of the nearest rotation matrix R
mat = np.array([[ 1., 0., 0.],
                [ 0., 1., 0.],
                [ 0., 0., scipy.linalg.det(np.dot(P,Q.transpose()))]])
R = np.dot(P,np.dot(mat,Q.transpose()))™ .GetValues()[Frame,:],
                             acq.GetPoint(â€™RPSIâ€™).GetValues()[Frame,:]])
# Difference with mean values
A = data_FrameRef-np.mean(data_FrameRef,axis=0)
B = data_FrameChosen-np.mean(data_FrameChosen,axis=0)
# transposition of the data
A = A.transpose()
B = B.transpose()
# matrix multiplication
# (Note : with a numpy array, itâ€™s the dot method, not the multiplication operator)
C = np.dot(B,A.transpose())
# singular decomposition, called the svd method of the scipy/linalg module
P,T,Q = scipy.linalg.svd(C)
# computation of the nearest rotation matrix R
mat = np.array([[ 1., 0., 0.],
                [ 0., 1., 0.],
                [ 0., 0., scipy.linalg.det(np.dot(P,Q.transpose()))]])
R = np.dot(P,np.dot(mat,Q.transpose()))).GetValues()[Frame,:],</div>
<div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;                             acq.GetPoint(â ™RPSIâ€™).GetValues()[Frame,:]])
# Difference with mean values
A = data_FrameRef-np.mean(data_FrameRef,axis=0)
B = data_FrameChosen-np.mean(data_FrameChosen,axis=0)
# transposition of the data
A = A.transpose()
B = B.transpose()
# matrix multiplication
# (Note : with a numpy array, itâ€™s the dot method, not the multiplication operator)
C = np.dot(B,A.transpose())
# singular decomposition, called the svd method of the scipy/linalg module
P,T,Q = scipy.linalg.svd(C)
# computation of the nearest rotation matrix R
mat = np.array([[ 1., 0., 0.],
                [ 0., 1., 0.],
                [ 0., 0., scipy.linalg.det(np.dot(P,Q.transpose()))]])
R = np.dot(P,np.dot(mat,Q.transpose()))€ RPSIâ€™).GetValues()[Frame,:]])
# Difference with mean values
A = data_FrameRef-np.mean(data_FrameRef,axis=0)
B = data_FrameChosen-np.mean(data_FrameChosen,axis=0)
# transposition of the data
A = A.transpose()
B = B.transpose()
# matrix multiplication
# (Note : with a numpy array, itâ€™s the dot method, not the multiplication operator)
C = np.dot(B,A.transpose())
# singular decomposition, called the svd method of the scipy/linalg module
P,T,Q = scipy.linalg.svd(C)
# computation of the nearest rotation matrix R
mat = np.array([[ 1., 0., 0.],
                [ 0., 1., 0.],
                [ 0., 0., scipy.linalg.det(np.dot(P,Q.transpose()))]])
R = np.dot(P,np.dot(mat,Q.transpose()))™ PSIâ€™).GetValues()[Frame,:]])
# Difference with mean values
A = data_FrameRef-np.mean(data_FrameRef,axis=0)
B = data_FrameChosen-np.mean(data_FrameChosen,axis=0)
# transposition of the data
A = A.transpose()
B = B.transpose()
# matrix multiplication
# (Note : with a numpy array, itâ€™s the dot method, not the multiplication operator)
C = np.dot(B,A.transpose())
# singular decomposition, called the svd method of the scipy/linalg module
P,T,Q = scipy.linalg.svd(C)
# computation of the nearest rotation matrix R
mat = np.array([[ 1., 0., 0.],
                [ 0., 1., 0.],
                [ 0., 0., scipy.linalg.det(np.dot(P,Q.transpose()))]])
R = np.dot(P,np.dot(mat,Q.transpose()))RPSIâ ™).GetValues()[Frame,:]])
# Difference with mean values
A = data_FrameRef-np.mean(data_FrameRef,axis=0)
B = data_FrameChosen-np.mean(data_FrameChosen,axis=0)
# transposition of the data
A = A.transpose()
B = B.transpose()
# matrix multiplication
# (Note : with a numpy array, itâ€™s the dot method, not the multiplication operator)
C = np.dot(B,A.transpose())
# singular decomposition, called the svd method of the scipy/linalg module
P,T,Q = scipy.linalg.svd(C)
# computation of the nearest rotation matrix R
mat = np.array([[ 1., 0., 0.],
                [ 0., 1., 0.],
                [ 0., 0., scipy.linalg.det(np.dot(P,Q.transpose()))]])
R = np.dot(P,np.dot(mat,Q.transpose()))€ ).GetValues()[Frame,:]])
# Difference with mean values
A = data_FrameRef-np.mean(data_FrameRef,axis=0)
B = data_FrameChosen-np.mean(data_FrameChosen,axis=0)
# transposition of the data
A = A.transpose()
B = B.transpose()
# matrix multiplication
# (Note : with a numpy array, itâ€™s the dot method, not the multiplication operator)
C = np.dot(B,A.transpose())
# singular decomposition, called the svd method of the scipy/linalg module
P,T,Q = scipy.linalg.svd(C)
# computation of the nearest rotation matrix R
mat = np.array([[ 1., 0., 0.],
                [ 0., 1., 0.],
                [ 0., 0., scipy.linalg.det(np.dot(P,Q.transpose()))]])
R = np.dot(P,np.dot(mat,Q.transpose()))™ .GetValues()[Frame,:]])
# Difference with mean values
A = data_FrameRef-np.mean(data_FrameRef,axis=0)
B = data_FrameChosen-np.mean(data_FrameChosen,axis=0)
# transposition of the data
A = A.transpose()
B = B.transpose()
# matrix multiplication
# (Note : with a numpy array, itâ€™s the dot method, not the multiplication operator)
C = np.dot(B,A.transpose())
# singular decomposition, called the svd method of the scipy/linalg module
P,T,Q = scipy.linalg.svd(C)
# computation of the nearest rotation matrix R
mat = np.array([[ 1., 0., 0.],
                [ 0., 1., 0.],
                [ 0., 0., scipy.linalg.det(np.dot(P,Q.transpose()))]])
R = np.dot(P,np.dot(mat,Q.transpose()))).GetValues()[Frame,:]])</div>
<div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;<span class="comment"># Difference with mean values</span></div>
<div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;A = data_FrameRef-np.mean(data_FrameRef,axis=0)</div>
<div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;B = data_FrameChosen-np.mean(data_FrameChosen,axis=0)</div>
<div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;<span class="comment"># transposition of the data</span></div>
<div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;A = A.transpose()</div>
<div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;B = B.transpose()</div>
<div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;<span class="comment"># matrix multiplication</span></div>
<div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;<span class="comment"># (Note : with a numpy array, itâ€™s the dot method, not the multiplication operator)</span></div>
<div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;C = np.dot(B,A.transpose())</div>
<div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;<span class="comment"># singular decomposition, called the svd method of the scipy/linalg module</span></div>
<div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;P,T,Q = scipy.linalg.svd(C)</div>
<div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;<span class="comment"># computation of the nearest rotation matrix R</span></div>
<div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;mat = np.array([[ 1., 0., 0.],</div>
<div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;                [ 0., 1., 0.],</div>
<div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;                [ 0., 0., scipy.linalg.det(np.dot(P,Q.transpose()))]])</div>
<div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;R = np.dot(P,np.dot(mat,Q.transpose()))</div>
</div><!-- fragment --> </div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Dec 27 2013 23:58:43 for BTK Python wrapper by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.5
</small></address>
</body>
</html>
